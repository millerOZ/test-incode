import type { Flow } from '../../../types/src';
import type { BaseFlowState } from './BaseFlowState';
export declare abstract class AbstractFlowManager<StepType, FlowType extends Flow, SuccessDataType, ErrorDetailType> {
    protected state: BaseFlowState<StepType, SuccessDataType, ErrorDetailType>;
    protected readonly initialState: Readonly<BaseFlowState<StepType, SuccessDataType, ErrorDetailType>>;
    private subscribers;
    protected flowConfig: FlowType | null;
    protected sessionToken: string | null;
    constructor(initialStateValues: Partial<BaseFlowState<StepType, SuccessDataType, ErrorDetailType>> & {
        currentStep: StepType | null;
    });
    subscribe(callback: (state: BaseFlowState<StepType, SuccessDataType, ErrorDetailType>) => void): () => void;
    protected notifySubscribers(): void;
    protected setState(newState: Partial<BaseFlowState<StepType, SuccessDataType, ErrorDetailType>>): void;
    getState(): BaseFlowState<StepType, SuccessDataType, ErrorDetailType>;
    getToken(): string | null;
    incrementAttempts(): void;
    protected resetAttempts(): void;
    canRetry(): boolean;
    initialize(config: {
        sessionToken: string;
    }): Promise<void>;
    reset(): void;
    protected abstract fetchFlowConfiguration(token: string): Promise<FlowType>;
    protected abstract determineInitialStep(flowConfig: FlowType): StepType;
    protected abstract getMaxAttemptsFromFlow(flowConfig: FlowType): number;
    protected abstract formatError(error: unknown): ErrorDetailType;
    protected abstract determineStepOnErrorDuringInit(error: unknown): StepType | null;
}
