"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Publisher = void 0;
const livekit_client_1 = require("livekit-client");
const StreamEvent_1 = require("../OpenViduInternal/Events/StreamEvent");
const OpenViduLogger_1 = require("../OpenViduInternal/Logger/OpenViduLogger");
const Platform_1 = require("../OpenViduInternal/Utils/Platform");
const Session_1 = require("./Session");
const Stream_1 = require("./Stream");
const StreamManager_1 = require("./StreamManager");
const InternalSignalTypes_1 = require("../OpenViduInternal/Interfaces/Private/InternalSignalTypes");
const StreamPropertyChangedEvent_1 = require("../OpenViduInternal/Events/StreamPropertyChangedEvent");
/**
 * @hidden
 */
const platform = Platform_1.PlatformUtils.getInstance();
/**
 * @hidden
 */
const logger = OpenViduLogger_1.OpenViduLogger.getInstance();
// It could represent the local participant from livekit
/**
 * Packs local media streams. Participants can publish it to a session. Initialized with {@link OpenVidu.initPublisher} method.
 *
 * See available event listeners at {@link PublisherEventMap}.
 */
class Publisher extends StreamManager_1.StreamManager {
    /**
     * @hidden
     */
    constructor(targetElement, properties, openvidu) {
        const session = openvidu.session ? openvidu.session : new Session_1.Session(openvidu);
        const options = {
            publisherProperties: properties,
            mediaConstraints: {}
        };
        const stream = new Stream_1.Stream(session, options);
        super(stream, targetElement);
        /**
         * @hidden
         * Flag indicating whether the Publisher requires reinitialization due to being unpublished from the session.
         * It is set to true only when the Publisher has been explicitly unpublished by the session.
         */
        this.shouldReinitializePublisher = false;
        /**
         * ! Not implemented yet
         * Whether you have called {@link Publisher.subscribeToRemote} with value `true` or `false` (*false* by default)
         */
        this.isSubscribedToRemote = false;
        this.accessDialogHasBeenOpened = false;
        this.ACCESS_DIALOG_TIMEOUT = 1500;
        this.stream = stream;
        this.properties = properties;
        this.openvidu = openvidu;
        this.session = session;
        this.stream.connection = session.connection;
        this.stream.ee.on('local-stream-destroyed', (reason) => {
            const sessionStreamEvent = new StreamEvent_1.StreamEvent(true, this.session, 'streamDestroyed', this.stream, reason);
            const publisherStreamEvent = new StreamEvent_1.StreamEvent(true, this, 'streamDestroyed', this.stream, reason);
            // this.session.publicEmmiter.emitEvent('streamDestroyed', [sessionStreamEvent]);
            this.emitEvent('streamDestroyed', [publisherStreamEvent]);
            publisherStreamEvent.callDefaultBehavior();
        });
    }
    /**
     * @hidden
     */
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            const myConstraints = this.openvidu.generateMediaConstraints(this.properties);
            const { constraints, audioTrack, videoTrack } = myConstraints;
            if (this.openvidu.isMediaTracksProvided(myConstraints)) {
                // No need to call getUserMedia. MediaStreamTracks already provided
                if (videoTrack) {
                    this.stream.videoTrack = new livekit_client_1.LocalVideoTrack(videoTrack, videoTrack.getConstraints(), true);
                }
                if (audioTrack) {
                    this.stream.audioTrack = new livekit_client_1.LocalAudioTrack(audioTrack, audioTrack.getConstraints(), true);
                }
                this.stream.streamReadyToPublish();
            }
            else {
                // MediaStreamTracks not provided. Must call getUserMedia
                const outboundStreamOptions = {
                    mediaConstraints: constraints,
                    publisherProperties: this.properties
                };
                this.stream.outboundStreamOpts = outboundStreamOptions;
                try {
                    if (platform.isElectron() && this.stream.isSendingScreen()) {
                        // Directly use the MediaStreamConstraints
                        myConstraints.constraints.audio = false;
                        yield this.handleScreenCaptureInElectron(myConstraints.constraints);
                    }
                    else if (this.shouldUseScreenCapture()) {
                        const screenOptions = this.openvidu.generateScreenCaptureOptionsFromConstraints(constraints);
                        yield this.handleScreenCapture(screenOptions);
                    }
                    else {
                        const videoOptions = this.openvidu.generateVideoCaptureOptionsFromContraints(constraints);
                        const audioOptions = this.openvidu.generateAudioCaptureOptionsFromContraints(constraints);
                        yield this.handleCameraAndMicrophone(videoOptions, audioOptions);
                    }
                    this.accessAllowed = true;
                    this.emitEvent('accessAllowed', []);
                    this.stream.streamReadyToPublish();
                    if (!this.session.isSessionConnected()) {
                        this.stream.isReadyToAttach = true;
                    }
                }
                catch (error) {
                    this.emitEvent('accessDenied', [error]);
                    throw error;
                }
                if (!!this.targetElement) {
                    this.createVideoElement(this.targetElement, this.properties.insertMode);
                }
            }
            this.reestablishStreamPlayingEvent();
        });
    }
    /**
     * Publish or unpublish the audio stream (if available). Calling this method twice in a row passing same `enabled` value will have no effect
     *
     * #### Events dispatched
     *
     * > _Only if `Session.publish(Publisher)` has been called for this Publisher_
     *
     * The {@link Session} object of the local participant will dispatch a `streamPropertyChanged` event with `changedProperty` set to `"audioActive"` and `reason` set to `"publishAudio"`
     * The {@link Publisher} object of the local participant will also dispatch the exact same event
     *
     * The {@link Session} object of every other participant connected to the session will dispatch a `streamPropertyChanged` event with `changedProperty` set to `"audioActive"` and `reason` set to `"publishAudio"`
     * The respective {@link Subscriber} object of every other participant receiving this Publisher's stream will also dispatch the exact same event
     *
     * See {@link StreamPropertyChangedEvent} to learn more.
     *
     * @param enabled `true` to publish the audio stream, `false` to unpublish it
     */
    publishAudio(enabled) {
        if (!this.session.isSessionConnected()) {
            this.publishAudioWhenSesssionIsNotConnected(enabled);
            return;
        }
        const audioTrackPublication = this.session.localParticipant
            .getTrackPublications()
            .find((track) => track.kind === livekit_client_1.Track.Kind.Audio);
        if (!audioTrackPublication) {
            logger.error('No audio track found');
            return;
        }
        const localAudioTrackPublication = audioTrackPublication;
        if (this.stream.audioActive !== enabled) {
            this.stream.audioActive = enabled;
            if (enabled) {
                localAudioTrackPublication
                    .unmute()
                    .then(() => {
                    logger.info("'Publisher' has " + (enabled ? 'published' : 'unpublished') + ' its audio stream');
                })
                    .catch((error) => {
                    logger.error('Error when publishing audio. Setting audio active to false', error);
                    this.stream.audioActive = false;
                });
            }
            else {
                localAudioTrackPublication
                    .mute()
                    .then(() => {
                    logger.info("'Publisher' has " + (enabled ? 'published' : 'unpublished') + ' its audio stream');
                })
                    .catch((error) => {
                    logger.error('Error when unpublishing audio. Setting audio active to true', error);
                    this.stream.audioActive = true;
                });
            }
        }
    }
    /**
     * Publishes or unpublishes the audio stream of the Publisher when session is not connected.
     * If enabled is true, the audio stream will be published. If enabled is false, the audio stream will be unpublished.
     *
     * @param enabled - A boolean flag indicating whether to enable or disable the audio stream.
     */
    publishAudioWhenSesssionIsNotConnected(enabled) {
        if (this.stream.audioActive !== enabled) {
            this.stream.audioActive = enabled;
            if (enabled) {
                this.stream.audioTrack
                    .unmute()
                    .then(() => {
                    logger.info(`'Publisher' has enabled its audio stream`);
                })
                    .catch((error) => {
                    logger.error('Error when publishing audio. Setting audio active to false', error);
                    this.stream.audioActive = false;
                });
            }
            else {
                this.stream.audioTrack
                    .mute()
                    .then(() => {
                    logger.info(`'Publisher' has disabled its audio stream`);
                })
                    .catch((error) => {
                    logger.error('Error when unpublishing audio. Setting audio active to true', error);
                    this.stream.audioActive = true;
                });
            }
        }
    }
    /**
     * Publish or unpublish the video stream (if available). Calling this method twice in a row passing same `enabled` value will have no effect
     *
     * #### Events dispatched
     *
     * > _Only if `Session.publish(Publisher)` has been called for this Publisher_
     *
     * The {@link Session} object of the local participant will dispatch a `streamPropertyChanged` event with `changedProperty` set to `"videoActive"` and `reason` set to `"publishVideo"`
     * The {@link Publisher} object of the local participant will also dispatch the exact same event
     *
     * The {@link Session} object of every other participant connected to the session will dispatch a `streamPropertyChanged` event with `changedProperty` set to `"videoActive"` and `reason` set to `"publishVideo"`
     * The respective {@link Subscriber} object of every other participant receiving this Publisher's stream will also dispatch the exact same event
     *
     * See {@link StreamPropertyChangedEvent} to learn more.
     *
     * @param enabled `true` to publish the video stream, `false` to unpublish it
     * @param resource
     *
     * If parameter **`enabled`** is `false`, this optional parameter is of type boolean. It can be set to `true` to forcibly free the hardware resource associated to the video track, or can be set to `false` to keep the access to the hardware resource.
     * Not freeing the resource makes the operation much more efficient, but depending on the platform two side-effects can be introduced: the video device may not be accessible by other applications and the access light of
     * webcams may remain on. This is platform-dependent: some browsers will not present the side-effects even when not freeing the resource.
     *
     * If parameter **`enabled`** is `true`, this optional parameter is of type [MediaStreamTrack](https://developer.mozilla.org/docs/Web/API/MediaStreamTrack). It can be set to force the restoration of the video track with a custom track. This may be
     * useful if the Publisher was unpublished freeing the hardware resource, and openvidu-browser-v2compatibility is not able to successfully re-create the video track as it was before unpublishing. In this way previous track settings will be ignored and this MediaStreamTrack
     * will be used instead.
     */
    publishVideo(enabled, resource) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.session.isSessionConnected()) {
                yield this.publishVideoWhenSesssionIsNotConnected(enabled, resource);
                return;
            }
            const videoTrackPublication = this.session.localParticipant
                .getTrackPublications()
                .find((track) => track.kind === livekit_client_1.Track.Kind.Video);
            if (!videoTrackPublication || !videoTrackPublication.track) {
                logger.error('No camera track found');
                return;
            }
            const localVideoTrackPublication = videoTrackPublication;
            if (this.stream.videoActive !== enabled) {
                if (enabled) {
                    if (resource != null && resource instanceof MediaStreamTrack) {
                        // OpenVidu compatibility for method "Publisher.publishVideo(true, mediaStreamTrack)"
                        if (resource.kind !== livekit_client_1.Track.Kind.Video) {
                            throw new Error('MediaStreamTrack provided is not of kind video');
                        }
                        // First replace the track before unmuting. Reminder that replacing the track also unmutes its attached videos
                        yield this.replaceTrack(resource);
                    }
                    yield this.runPromiseAndMuteLocalVideosIfNeeded(() => localVideoTrackPublication.videoTrack.unmute());
                }
                else {
                    if (resource) {
                        // Free the hardware resource associated to the video track
                        (_a = localVideoTrackPublication.videoTrack) === null || _a === void 0 ? void 0 : _a.stop();
                    }
                    yield ((_b = localVideoTrackPublication.videoTrack) === null || _b === void 0 ? void 0 : _b.mute());
                }
                this.stream.videoActive = enabled;
                const action = enabled ? 'published' : 'unpublished';
                logger.info(`'Publisher' has ${action} its video stream`);
            }
        });
    }
    /**
     * Publishes the video when the session is not connected.
     *
     * @param enabled - A boolean indicating whether the video should be enabled or disabled.
     * @param resource - A boolean, MediaStreamTrack, or undefined representing the video resource.
     * @returns A Promise that resolves when the video is published.
     */
    publishVideoWhenSesssionIsNotConnected(enabled, resource) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.stream.videoActive !== enabled) {
                const videoTrack = this.stream.videoTrack;
                if (enabled) {
                    if (resource != null && resource instanceof MediaStreamTrack) {
                        // OpenVidu compatibility for method "Publisher.publishVideo(true, mediaStreamTrack)"
                        if (resource.kind !== livekit_client_1.Track.Kind.Video) {
                            throw new Error('MediaStreamTrack provided is not of kind video');
                        }
                        // When the session is not connected, as the video track is created with property userProvidedTrack = true,
                        // replacing the track restarts it. Hence, there's no need to explicitly call unmute(),
                        // as the unmute() method of a LocalVideoTrack also restarts the track.
                        yield this.replaceTrack(resource);
                        videoTrack['setTrackMuted'](false);
                    }
                    else {
                        yield this.runPromiseAndMuteLocalVideosIfNeeded(() => videoTrack.unmute());
                    }
                }
                else {
                    if (resource) {
                        // Free the hardware resource associated to the video track
                        videoTrack.stop();
                    }
                    yield videoTrack.mute();
                }
                this.stream.videoActive = enabled;
                const action = enabled ? 'enabled' : 'disabled';
                logger.info(`'Publisher' has ${action} its video stream`);
            }
        });
    }
    /**
     * Replaces the current video or audio track with a different one. This allows you to replace an ongoing track with a different one
     * without having to renegotiate the whole WebRTC connection (that is, initializing a new Publisher, unpublishing the previous one
     * and publishing the new one).
     *
     * You can get this new MediaStreamTrack by using the native Web API or simply with {@link OpenVidu.getUserMedia} method.
     *
     * **WARNING: this method has been proven to work in the majority of cases, but there may be some combinations of published/replaced tracks that may be incompatible
     * between them and break the connection in OpenVidu Server. A complete renegotiation may be the only solution in this case.
     * Visit [RTCRtpSender.replaceTrack](https://developer.mozilla.org/en-US/docs/Web/API/RTCRtpSender/replaceTrack) documentation for further details.**
     *
     * @param track The [MediaStreamTrack](https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack) object to replace the current one.
     * If it is an audio track, the current audio track will be the replaced one. If it is a video track, the current video track will be the replaced one.
     *
     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the track was successfully replaced and rejected with an Error object in other case
     */
    replaceTrack(track) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.session.isSessionConnected()) {
                yield this.replaceTrackWhenSessionIsNotConnected(track);
                return;
            }
            const localTrackPublication = this.session.localParticipant
                .getTrackPublications()
                .find((t) => t.kind === track.kind);
            if (!localTrackPublication || !localTrackPublication.track) {
                logger.error('No local track found');
                return;
            }
            const oldTrack = localTrackPublication.track;
            yield this.runPromiseAndMuteLocalVideosIfNeeded(() => oldTrack.replaceTrack(track));
            if (localTrackPublication.kind === livekit_client_1.Track.Kind.Audio) {
                // Reset hark events using the new audio track
                this.stream.disableAllHarkEvents();
                this.stream.initHarkEvents();
            }
            else if (localTrackPublication.kind === livekit_client_1.Track.Kind.Video) {
                this.openvidu.sendNewVideoDimensionsIfRequired(this, 'trackReplaced', 75, 30);
            }
            // streamPropertyChanged event
            yield this.sendReplaceTrackEvent(track, oldTrack.mediaStreamTrack);
        });
    }
    /**
     * Replaces the media track when the session is not connected.
     *
     * @param track - The new media stream track to replace the existing track.
     * @returns A promise that resolves when the track replacement is complete.
     */
    replaceTrackWhenSessionIsNotConnected(track) {
        return __awaiter(this, void 0, void 0, function* () {
            const isAudioTrack = track.kind === livekit_client_1.Track.Kind.Audio;
            const oldTrack = isAudioTrack ? this.stream.audioTrack : this.stream.videoTrack;
            const constraints = {
                [isAudioTrack ? 'audio' : 'video']: track.getConstraints()
            };
            const options = isAudioTrack
                ? this.openvidu.generateAudioCaptureOptionsFromContraints(constraints)
                : this.openvidu.generateVideoCaptureOptionsFromContraints(constraints);
            yield this.runPromiseAndMuteLocalVideosIfNeeded(() => oldTrack.restartTrack(options));
            if (track.kind === livekit_client_1.Track.Kind.Audio) {
                // Reset hark events using the new audio track
                this.stream.disableAllHarkEvents();
                this.stream.initHarkEvents();
            }
            else if (track.kind === livekit_client_1.Track.Kind.Video) {
                this.openvidu.sendNewVideoDimensionsIfRequired(this, 'trackReplaced', 75, 30);
            }
            // Stop the track provided by the user with the aim of freeing the hardware resource
            track.stop();
            yield this.sendReplaceTrackEvent(track, oldTrack.mediaStreamTrack);
        });
    }
    /**
     * See {@link EventDispatcher.on}
     */
    on(type, handler) {
        super.on(type, handler);
        return this;
    }
    /**
     * See {@link EventDispatcher.once}
     */
    once(type, handler) {
        super.once(type, handler);
        return this;
    }
    /**
     * See {@link EventDispatcher.off}
     */
    off(type, handler) {
        super.off(type, handler);
        return this;
    }
    /**
     * @deprecated
     * Call this method before {@link Session.publish} if you prefer to subscribe to your Publisher's remote stream instead of using the local stream, as any other user would do.
     */
    subscribeToRemote(value) {
        logger.warn("'subscribeToRemote' method has been deprecated");
    }
    /**
     * @hidden
     */
    replaceTrackInMediaStream(track, updateLastConstraints) {
        throw new Error('Method not implemented.');
    }
    shouldUseScreenCapture() {
        return this.stream.isSendingScreen() && !platform.isElectron();
    }
    handleCameraAndMicrophone(videoOptions, audioOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            this.stream.videoOptions = videoOptions;
            this.stream.audioOptions = audioOptions;
            const opts = {
                audio: this.stream.audioOptions,
                video: this.stream.videoOptions
            };
            try {
                this.startAccessDialogTimer();
                const localTracks = yield (0, livekit_client_1.createLocalTracks)(opts);
                this.stopAccessDialogTimer();
                this.stream.videoTrack = localTracks.find((t) => t.kind === livekit_client_1.Track.Kind.Video);
                this.stream.audioTrack = localTracks.find((t) => t.kind === livekit_client_1.Track.Kind.Audio);
            }
            catch (error) {
                throw livekit_client_1.MediaDeviceFailure.getFailure(error);
            }
            finally {
                this.stopAccessDialogTimer();
            }
        });
    }
    handleScreenCapture(screenOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            this.stream.screenShareOptions = screenOptions;
            try {
                this.startAccessDialogTimer();
                const tracks = yield this.session.localParticipant.createScreenTracks(screenOptions);
                this.stopAccessDialogTimer();
                this.stream.videoTrack = tracks.find((t) => t.kind === livekit_client_1.Track.Kind.Video);
                this.stream.audioTrack = tracks.find((t) => t.kind === livekit_client_1.Track.Kind.Audio);
                // If no screen audio, check if other audio tracks must be set
                if (this.properties.audioSource === true || this.properties.audioSource === undefined) {
                    this.startAccessDialogTimer();
                    this.stream.audioTrack = yield (0, livekit_client_1.createLocalAudioTrack)();
                    this.stopAccessDialogTimer();
                }
                else if (this.properties.audioSource instanceof MediaStreamTrack) {
                    this.stream.audioTrack = new livekit_client_1.LocalAudioTrack(this.properties.audioSource, undefined, true);
                }
            }
            catch (error) {
                throw livekit_client_1.MediaDeviceFailure.getFailure(error);
            }
            finally {
                this.stopAccessDialogTimer();
            }
        });
    }
    handleScreenCaptureInElectron(constraints) {
        return __awaiter(this, void 0, void 0, function* () {
            const mediaStream = yield navigator.mediaDevices.getUserMedia(constraints);
            const mediaStreamTrack = mediaStream.getVideoTracks()[0];
            const localVideoTrack = new livekit_client_1.LocalVideoTrack(mediaStreamTrack);
            localVideoTrack.source = livekit_client_1.Track.Source.ScreenShare;
            this.stream.videoTrack = localVideoTrack;
        });
    }
    /**
     * Sends a streamPropertyChanged event in the all ways (from publisher, subscriber and session)
     *
     * @param newTrack - The new MediaStreamTrack to replace.
     * @returns A Promise that resolves when the event is sent.
     */
    sendReplaceTrackEvent(newTrack, oldTrack) {
        return __awaiter(this, void 0, void 0, function* () {
            const isAudioTrack = newTrack.kind === livekit_client_1.Track.Kind.Audio;
            const changedProperty = isAudioTrack ? 'audioTrack' : 'videoTrack';
            const newValue = { label: newTrack.label };
            const oldValue = { label: oldTrack.label };
            const reason = 'trackReplaced';
            const sessionEvent = new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(this.session, this.stream, changedProperty, newValue, oldValue, reason);
            const streamManagerEvent = new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(this, this.stream, changedProperty, newValue, oldValue, reason);
            // Trigger local events
            this.session.publicEmmiter.emitEvent('streamPropertyChanged', [sessionEvent]);
            this.publicEmmiter.emitEvent('streamPropertyChanged', [streamManagerEvent]);
            // Send signal to other participants
            // The signals handler will send the event from the session and the subscriber
            const opt = {
                data: JSON.stringify({
                    sentFromServer: false,
                    payload: { changedProperty, newValue, oldValue, reason, participantIdentity: this.session.room.localParticipant.identity }
                }),
                type: `${InternalSignalTypes_1.InternalSignalType.CUSTOM_CLIENT_SIGNAL_PREFIX}${InternalSignalTypes_1.InternalSignalType.OPENVIDU_STREAM_PROPERTY_CHANGED}`
            };
            if (this.session.isSessionConnected()) {
                yield this.session.signalInternal(opt, false);
            }
        });
    }
    /**
     * @hidden
     */
    reestablishStreamPlayingEvent() {
        if (this.publicEmmiter.getListeners('streamPlaying').length > 0) {
            this.addPlayEventToFirstVideo();
        }
    }
    startAccessDialogTimer() {
        this.accessDialogTimeout = setTimeout(() => {
            this.emitEvent('accessDialogOpened', []);
            this.accessDialogHasBeenOpened = true;
        }, this.ACCESS_DIALOG_TIMEOUT);
    }
    stopAccessDialogTimer() {
        if (!!this.accessDialogTimeout) {
            clearTimeout(this.accessDialogTimeout);
            this.accessDialogTimeout = undefined;
            if (this.accessDialogHasBeenOpened) {
                this.accessDialogHasBeenOpened = false;
                this.emitEvent('accessDialogClosed', []);
            }
        }
    }
    /**
     * @hidden
     */
    runPromiseAndMuteLocalVideosIfNeeded(promise) {
        return __awaiter(this, void 0, void 0, function* () {
            // Store the previous muted value for local videos
            // This protects the muted value if the user has changed it for whatever reason
            const wasPreviouslyMuted = new Map();
            this.videos.forEach((video) => {
                wasPreviouslyMuted.set(video.id, video.video.muted);
            });
            // Run the promise that may perform unwanted local video unmutes
            yield promise();
            // Re-mute local videos again only if they were muted before
            this.videos.forEach((video) => {
                const wasMuted = wasPreviouslyMuted.get(video.id);
                video.video.muted = wasMuted != null ? wasMuted : true;
            });
        });
    }
}
exports.Publisher = Publisher;
//# sourceMappingURL=Publisher.js.map