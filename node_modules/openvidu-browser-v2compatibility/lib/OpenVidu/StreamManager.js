"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamManager = void 0;
const StreamManagerEvent_1 = require("../OpenViduInternal/Events/StreamManagerEvent");
const OpenViduLogger_1 = require("../OpenViduInternal/Logger/OpenViduLogger");
const EventDispatcher_1 = require("./EventDispatcher");
const VideoInsertMode_1 = require("../OpenViduInternal/Enums/VideoInsertMode");
const VideoElementEvent_1 = require("../OpenViduInternal/Events/VideoElementEvent");
const ExceptionEvent_1 = require("../OpenViduInternal/Events/ExceptionEvent");
/**
 * @hidden
 */
const logger = OpenViduLogger_1.OpenViduLogger.getInstance();
class StreamManager extends EventDispatcher_1.EventDispatcher {
    /**
     * @hidden
     */
    constructor(stream, targetElement) {
        super();
        /**
         * All the videos displaying the Stream of this Publisher/Subscriber
         */
        this.videos = [];
        /**
         * @hidden
         */
        this.lazyLaunchVideoElementCreatedEvent = false;
        /**
         * @hidden
         */
        this.canPlayListener = (ev) => {
            // Clean the listener on the first event!
            ev.srcElement.removeEventListener('canplay', this.canPlayListener);
            this.deactivateStreamPlayingEventExceptionTimeout();
            const event = new StreamManagerEvent_1.StreamManagerEvent(this, 'streamPlaying', undefined);
            this.emitEvent('streamPlaying', [event]);
        };
        this.internalSubs = new Map();
        this.stream = stream;
        this.stream.streamManager = this;
        this.targetElement = targetElement;
        this.remote = !this.stream.isLocal();
        if (!!targetElement) {
            let targetElementAux = null;
            if (typeof targetElement === 'string') {
                targetElementAux = document.getElementById(targetElement);
            }
            else if (targetElement instanceof HTMLElement) {
                targetElementAux = targetElement;
            }
            if (targetElementAux) {
                // this.firstVideoElement = {
                //     targetElement: targetElementAux,
                //     video: document.createElement('video'),
                //     id: '',
                //     canplayListenerAdded: false
                // };
                //         if (
                //             platform.isSafariBrowser() ||
                //             (platform.isIPhoneOrIPad() &&
                //                 (platform.isChromeMobileBrowser() ||
                //                     platform.isEdgeMobileBrowser() ||
                //                     platform.isOperaMobileBrowser() ||
                //                     platform.isFirefoxMobileBrowser()))
                //         ) {
                //             this.firstVideoElement.video.playsInline = true;
                //         }
                this.targetElement = targetElementAux;
                // this.element = targetElementAux;
            }
        }
        this.setupReadyToAttachListener();
    }
    /**
     * @hidden
     */
    setupReadyToAttachListener() {
        this.stream.ee.once('openvidu-stream-ready-to-attach', () => {
            this.videos.forEach((streamManagerVideo) => {
                this.attachTracks(streamManagerVideo.video);
                this.initializeVideoPropertiesAux(streamManagerVideo);
            });
        });
    }
    /**
     * Makes `video` element parameter display this {@link stream}. This is useful when you are
     * [managing the video elements on your own](/en/stable/cheatsheet/manage-videos/#you-take-care-of-the-video-players)
     *
     * Calling this method with a video already added to other Publisher/Subscriber will cause the video element to be
     * disassociated from that previous Publisher/Subscriber and to be associated to this one.
     *
     * @returns 1 if the video wasn't associated to any other Publisher/Subscriber and has been successfully added to this one.
     * 0 if the video was already added to this Publisher/Subscriber. -1 if the video was previously associated to any other
     * Publisher/Subscriber and has been successfully disassociated from that one and properly added to this one.
     */
    addVideoElement(video) {
        // If the video element is already part of this StreamManager do nothing
        for (const v of this.videos) {
            if (v.video === video) {
                return 0;
            }
        }
        let returnNumber = 1;
        for (const streamManager of this.stream.session.streamManagers) {
            if (streamManager.disassociateVideo(video)) {
                returnNumber = -1;
                break;
            }
        }
        this.stream.session.streamManagers.forEach((streamManager) => {
            streamManager.disassociateVideo(video);
        });
        this.pushNewStreamManagerVideo({
            video,
            id: video.id,
            canplayListenerAdded: false
        });
        logger.info('New video element associated to ', this);
        return returnNumber;
    }
    /**
     * @hidden
     */
    disassociateVideo(video) {
        let disassociated = false;
        for (let i = 0; i < this.videos.length; i++) {
            if (this.videos[i].video === video) {
                this.videos[i].video.removeEventListener('canplay', this.canPlayListener);
                this.videos.splice(i, 1);
                disassociated = true;
                logger.info('Video element disassociated from ', this);
                break;
            }
        }
        return disassociated;
    }
    /**
     * @hidden
     */
    addPlayEventToFirstVideo() {
        if (!!this.videos[0] && !!this.videos[0].video && !this.videos[0].canplayListenerAdded) {
            this.activateStreamPlayingEventExceptionTimeout();
            this.videos[0].video.addEventListener('canplay', this.canPlayListener);
            this.videos[0].canplayListenerAdded = true;
        }
    }
    /**
     * Creates a new video element displaying this {@link stream}. This allows you to have multiple video elements displaying the same media stream.
     *
     * #### Events dispatched
     *
     * The Publisher/Subscriber object will dispatch a `videoElementCreated` event once the HTML video element has been added to DOM. See {@link VideoElementEvent}
     *
     * @param targetElement HTML DOM element (or its `id` attribute) in which the video element of the Publisher/Subscriber will be inserted
     * @param insertMode How the video element will be inserted accordingly to `targetElemet`
     *
     * @returns The created HTMLVideoElement
     */
    createVideoElement(targetElement, insertMode) {
        var _a, _b, _c;
        let targEl = null;
        if (typeof targetElement === 'string') {
            targEl = document.getElementById(targetElement);
        }
        else if (targetElement instanceof HTMLElement) {
            targEl = targetElement;
        }
        if (!targEl) {
            throw new Error("The provided 'targetElement' couldn't be resolved to any HTML element: " + targetElement);
        }
        const video = document.createElement('video');
        let insMode = insertMode || VideoInsertMode_1.VideoInsertMode.APPEND;
        switch (insMode) {
            case VideoInsertMode_1.VideoInsertMode.AFTER:
                (_a = targEl.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(video, targEl.nextSibling);
                break;
            case VideoInsertMode_1.VideoInsertMode.APPEND:
                targEl.appendChild(video);
                break;
            case VideoInsertMode_1.VideoInsertMode.BEFORE:
                (_b = targEl.parentNode) === null || _b === void 0 ? void 0 : _b.insertBefore(video, targEl);
                break;
            case VideoInsertMode_1.VideoInsertMode.PREPEND:
                targEl.insertBefore(video, targEl.firstChild);
                break;
            case VideoInsertMode_1.VideoInsertMode.REPLACE:
                (_c = targEl.parentNode) === null || _c === void 0 ? void 0 : _c.replaceChild(video, targEl);
                break;
            default:
                insMode = VideoInsertMode_1.VideoInsertMode.APPEND;
                targEl.appendChild(video);
                break;
        }
        const streamManagerVideo = {
            targetElement: targEl,
            video,
            insertMode: insMode,
            id: video.id,
            canplayListenerAdded: false
        };
        this.pushNewStreamManagerVideo(streamManagerVideo);
        const subscriberTimeout = this.remote ? 500 : 0;
        setTimeout(() => {
            // This timeout ensures that the videoElementCreated event is triggered correctly.
            // Without this delay, the event might be fired before the subscriber object is returned,
            // causing the event listener to be set after the event has already been fired.
            const event = new VideoElementEvent_1.VideoElementEvent(video, this, 'videoElementCreated');
            this.emitEvent('videoElementCreated', [event]);
        }, subscriberTimeout);
        return video;
    }
    /**
     * Updates the current configuration for the {@link PublisherSpeakingEvent} feature and the [StreamManagerEvent.streamAudioVolumeChange](/en/stable/api/openvidu-browser-v2compatibility/classes/StreamManagerEvent.html) feature for this specific
     * StreamManager audio stream, overriding the global options set with {@link OpenVidu.setAdvancedConfiguration}. This way you can customize the audio events options
     * for each specific StreamManager and change them dynamically.
     *
     * @param publisherSpeakingEventsOptions New options to be applied to this StreamManager's audio stream. It is an object which includes the following optional properties:
     * - `interval`: (number) how frequently the analyser polls the audio stream to check if speaking has started/stopped or audio volume has changed. Default **100** (ms)
     * - `threshold`: (number) the volume at which _publisherStartSpeaking_, _publisherStopSpeaking_ events will be fired. Default **-50** (dB)
     */
    updatePublisherSpeakingEventsOptions(publisherSpeakingEventsOptions) {
        const currentHarkOptions = !!this.stream.harkOptions
            ? this.stream.harkOptions
            : this.stream.session.openvidu.advancedConfiguration.publisherSpeakingEventsOptions || {};
        const newInterval = typeof publisherSpeakingEventsOptions.interval === 'number'
            ? publisherSpeakingEventsOptions.interval
            : typeof currentHarkOptions.interval === 'number'
                ? currentHarkOptions.interval
                : 100;
        const newThreshold = typeof publisherSpeakingEventsOptions.threshold === 'number'
            ? publisherSpeakingEventsOptions.threshold
            : typeof currentHarkOptions.threshold === 'number'
                ? currentHarkOptions.threshold
                : -50;
        this.stream.harkOptions = {
            interval: newInterval,
            threshold: newThreshold
        };
        if (!!this.stream.speechEvent) {
            this.stream.speechEvent.setInterval(newInterval);
            this.stream.speechEvent.setThreshold(newThreshold);
        }
    }
    /**
     * @hidden
     */
    anySpeechEventListenerEnabled(event, onlyOnce) {
        let listenersInStreamManager = 0;
        let handlersInStreamManager = this.publicEmmiter.getListeners(event);
        if (onlyOnce) {
            handlersInStreamManager = handlersInStreamManager.filter((h) => h.once);
        }
        listenersInStreamManager = handlersInStreamManager.length;
        return listenersInStreamManager > 0;
    }
    pushNewStreamManagerVideo(streamManagerVideo) {
        this.videos.push(streamManagerVideo);
        this.initializeVideoProperties(streamManagerVideo);
        this.addPlayEventToFirstVideo();
        if (this.stream.session.streamManagers.indexOf(this) === -1) {
            this.stream.session.streamManagers.push(this);
        }
    }
    /**
     * @hidden
     */
    initializeVideoProperties(streamManagerVideo) {
        if (this.stream.isReadyToAttach) {
            // The stream already triggered "openvidu-stream-ready-to-attach"
            this.attachTracks(streamManagerVideo.video);
            this.initializeVideoPropertiesAux(streamManagerVideo);
        }
    }
    initializeVideoPropertiesAux(streamManagerVideo) {
        streamManagerVideo.video.autoplay = true;
        streamManagerVideo.video.controls = false;
        streamManagerVideo.video.playsInline = true;
        streamManagerVideo.video.muted = !this.remote;
        streamManagerVideo.video.dataset.openviduType = this.remote ? 'remote' : 'local';
        streamManagerVideo.video.dataset.openviduId = this.stream.streamId + '_' + this.stream.session.localParticipant.identity;
        if (!streamManagerVideo.video.id) {
            streamManagerVideo.video.id =
                (this.remote ? 'remote' : 'local') + '-video-' + this.stream.session.localParticipant.identity + '-' + this.stream.streamId;
        }
        streamManagerVideo.id = streamManagerVideo.video.id;
        // DEPRECATED property: assign once the property id if the user provided a valid targetElement
        if (!this.id && !!this.targetElement) {
            this.id = streamManagerVideo.id;
        }
        if (this.remote && this.isMirrored(streamManagerVideo.video)) {
            // Subscriber video associated to a previously mirrored video element
            this.setMirror(false, streamManagerVideo.video);
        }
        else if (!this.remote) {
            if (this.isMirrored(streamManagerVideo.video) && !this.stream.outboundStreamOpts.publisherProperties.mirror) {
                // If the video was already rotated and now is set to not mirror
                this.setMirror(false, streamManagerVideo.video);
            }
            else if (this.stream.outboundStreamOpts.publisherProperties.mirror && !this.stream.isSendingScreen()) {
                // If the video is now set to mirror and is not screen share
                this.setMirror(true, streamManagerVideo.video);
            }
            else if (this.stream.isSendingScreen()) {
                // If the video is screen share
                this.setMirror(false, streamManagerVideo.video);
            }
        }
    }
    attachTracks(video) {
        var _a, _b;
        if (this.remote) {
            logger.log(`Initializing video for remote stream ${this.stream.streamId}`, this.stream, video);
            this.stream.connection.participant.getTrackPublications().forEach((publication) => {
                var _a;
                logger.debug('Attaching remote track to video', publication);
                (_a = publication.track) === null || _a === void 0 ? void 0 : _a.attach(video);
            });
        }
        else {
            logger.log(`Initializing video for local stream ${this.stream.streamId}`, this.stream, video);
            if (this.stream.session.isSessionConnected()) {
                this.stream.session.localParticipant.getTrackPublications().forEach((publication) => {
                    var _a;
                    logger.debug('Attaching local track publication to video ', publication);
                    (_a = publication.track) === null || _a === void 0 ? void 0 : _a.attach(video);
                });
            }
            else {
                logger.debug('Session is not connected. Attaching video and audio tracks to video element.');
                (_a = this.stream.videoTrack) === null || _a === void 0 ? void 0 : _a.attach(video);
                (_b = this.stream.audioTrack) === null || _b === void 0 ? void 0 : _b.attach(video);
            }
        }
    }
    setMirror(mirror, video) {
        if (mirror) {
            video.style.transform = 'scaleX(-1)';
        }
        else {
            video.style.transform = 'unset';
        }
    }
    isMirrored(video) {
        return video.style.transform === 'scaleX(-1)';
    }
    /**
     * @hidden
     */
    emitEvent(type, eventArray) {
        this.publicEmmiter.emitEvent(type, eventArray);
    }
    /**
     * See {@link EventDispatcher.on}
     */
    on(type, handler) {
        super.onAux(type, "Event '" + type + "' triggered by '" + (this.remote ? 'Subscriber' : 'Publisher') + "'", handler);
        if (type === 'videoElementCreated') {
            if (!!this.stream && this.lazyLaunchVideoElementCreatedEvent) {
                const event = new VideoElementEvent_1.VideoElementEvent(this.videos[0].video, this, 'videoElementCreated');
                this.emitEvent('videoElementCreated', [event]);
                this.lazyLaunchVideoElementCreatedEvent = false;
            }
        }
        switch (type) {
            case 'publisherStartSpeaking':
                this.stream.enableHarkSpeakingEvent();
                break;
            case 'publisherStopSpeaking':
                this.stream.enableHarkStoppedSpeakingEvent();
                break;
            case 'streamAudioVolumeChange':
                this.stream.enableHarkVolumeChangeEvent(false);
                break;
        }
        return this;
    }
    /**
     * See {@link EventDispatcher.on}
     */
    once(type, handler) {
        super.onceAux(type, "Event '" + type + "' triggered by '" + (this.remote ? 'Subscriber' : 'Publisher') + "'", handler);
        if (type === 'videoElementCreated') {
            if (!!this.stream && this.lazyLaunchVideoElementCreatedEvent) {
                const event = new VideoElementEvent_1.VideoElementEvent(this.videos[0].video, this, 'videoElementCreated');
                this.emitEvent('videoElementCreated', [event]);
                this.lazyLaunchVideoElementCreatedEvent = false;
            }
        }
        switch (type) {
            case 'publisherStartSpeaking':
                this.stream.enableOnceHarkSpeakingEvent();
                break;
            case 'publisherStopSpeaking':
                this.stream.enableOnceHarkStoppedSpeakingEvent();
                break;
            case 'streamAudioVolumeChange':
                this.stream.enableOnceHarkVolumeChangeEvent(false);
                break;
        }
        return this;
    }
    /**
     * See {@link EventDispatcher.off}
     */
    off(type, handler) {
        super.offAux(type, handler);
        switch (type) {
            case 'publisherStartSpeaking':
                // Both StreamManager and Session can have "publisherStartSpeaking" event listeners
                const remainingStartSpeakingEventListeners = this.publicEmmiter.getListeners(type).length + this.stream.session.publicEmmiter.getListeners(type).length;
                if (remainingStartSpeakingEventListeners === 0) {
                    this.stream.disableHarkSpeakingEvent(false);
                }
                break;
            case 'publisherStopSpeaking':
                // Both StreamManager and Session can have "publisherStopSpeaking" event listeners
                const remainingStopSpeakingEventListeners = this.publicEmmiter.getListeners(type).length + this.stream.session.publicEmmiter.getListeners(type).length;
                if (remainingStopSpeakingEventListeners === 0) {
                    this.stream.disableHarkStoppedSpeakingEvent(false);
                }
                break;
            case 'streamAudioVolumeChange':
                // Only StreamManager can have "streamAudioVolumeChange" event listeners
                const remainingVolumeEventListeners = this.publicEmmiter.getListeners(type).length;
                if (remainingVolumeEventListeners === 0) {
                    this.stream.disableHarkVolumeChangeEvent(false);
                }
                break;
        }
        return this;
    }
    removeAllVideos() {
        for (let i = this.stream.session.streamManagers.length - 1; i >= 0; --i) {
            if (this.stream.session.streamManagers[i] === this) {
                this.stream.session.streamManagers.splice(i, 1);
            }
        }
        this.videos.forEach((streamManagerVideo) => {
            // Remove oncanplay event listener (only OpenVidu browser listener, not the user ones)
            if (!!streamManagerVideo.video && !!streamManagerVideo.video.removeEventListener) {
                streamManagerVideo.video.removeEventListener('canplay', this.canPlayListener);
            }
            streamManagerVideo.canplayListenerAdded = false;
            if (!!streamManagerVideo.targetElement) {
                // Only remove from DOM videos created by OpenVidu Browser (those generated by passing a valid targetElement in OpenVidu.initPublisher
                // and Session.subscribe or those created by StreamManager.createVideoElement). All this videos triggered a videoElementCreated event
                streamManagerVideo.video.remove();
                const event = new VideoElementEvent_1.VideoElementEvent(streamManagerVideo.video, this, 'videoElementDestroyed');
                this.emitEvent('videoElementDestroyed', [event]);
            }
            // Remove srcObject from the video
            streamManagerVideo.video.srcObject = null;
            this.deactivateStreamPlayingEventExceptionTimeout();
        });
        // Remove from collection of videos every video managed by OpenVidu Browser
        this.videos = this.videos.filter((v) => !v.targetElement);
    }
    activateStreamPlayingEventExceptionTimeout() {
        if (!this.remote) {
            // ExceptionEvent NO_STREAM_PLAYING_EVENT is only for subscribers
            return;
        }
        if (this.streamPlayingEventExceptionTimeout != null) {
            // The timeout is already activated
            return;
        }
        // Trigger ExceptionEvent NO_STREAM_PLAYING_EVENT if after timeout there is no 'canplay' event
        const msTimeout = this.stream.session.openvidu.advancedConfiguration.noStreamPlayingEventExceptionTimeout || 4000;
        this.streamPlayingEventExceptionTimeout = setTimeout(() => {
            const msg = 'StreamManager of Stream ' +
                this.stream.streamId +
                ' (' +
                (this.remote ? 'Subscriber' : 'Publisher') +
                ') did not trigger "streamPlaying" event in ' +
                msTimeout +
                ' ms';
            logger.warn(msg);
            this.stream.session.publicEmmiter.emitEvent('exception', [
                new ExceptionEvent_1.ExceptionEvent(this.stream.session, ExceptionEvent_1.ExceptionEventName.NO_STREAM_PLAYING_EVENT, this, msg)
            ]);
            delete this.streamPlayingEventExceptionTimeout;
        }, msTimeout);
    }
    deactivateStreamPlayingEventExceptionTimeout() {
        clearTimeout(this.streamPlayingEventExceptionTimeout);
        delete this.streamPlayingEventExceptionTimeout;
    }
}
exports.StreamManager = StreamManager;
//# sourceMappingURL=StreamManager.js.map