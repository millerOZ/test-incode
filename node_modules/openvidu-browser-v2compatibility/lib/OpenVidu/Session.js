"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Session = void 0;
const livekit_client_1 = require("livekit-client");
const egress_sdk_1 = require("@livekit/egress-sdk");
const Connection_1 = require("./Connection");
const EventDispatcher_1 = require("./EventDispatcher");
const SessionDisconnectedEvent_1 = require("../OpenViduInternal/Events/SessionDisconnectedEvent");
const Platform_1 = require("../OpenViduInternal/Utils/Platform");
const ConnectionEvent_1 = require("../OpenViduInternal/Events/ConnectionEvent");
const StreamEvent_1 = require("../OpenViduInternal/Events/StreamEvent");
const Subscriber_1 = require("./Subscriber");
const OpenViduError_1 = require("../OpenViduInternal/Enums/OpenViduError");
const VideoInsertMode_1 = require("../OpenViduInternal/Enums/VideoInsertMode");
const OpenViduLogger_1 = require("../OpenViduInternal/Logger/OpenViduLogger");
const InternalSignalTypes_1 = require("../OpenViduInternal/Interfaces/Private/InternalSignalTypes");
const ConnectionPropertyChangedEvent_1 = require("../OpenViduInternal/Events/ConnectionPropertyChangedEvent");
const RecordingEvent_1 = require("../OpenViduInternal/Events/RecordingEvent");
const NetworkQualityLevelChangedEvent_1 = require("../OpenViduInternal/Events/NetworkQualityLevelChangedEvent");
const StreamPropertyChangedEvent_1 = require("../OpenViduInternal/Events/StreamPropertyChangedEvent");
const SignalEvent_1 = require("../OpenViduInternal/Events/SignalEvent");
const WebSocket_1 = require("../OpenViduInternal/WebSocket/WebSocket");
/**
 * @hidden
 */
let platform = Platform_1.PlatformUtils.getInstance();
/**
 * @hidden
 */
const logger = OpenViduLogger_1.OpenViduLogger.getInstance();
/**
 * Livekit Room
 */
class Session extends EventDispatcher_1.EventDispatcher {
    /**
     * Unique identifier of the Session
     */
    get sessionId() {
        return this.room.name;
    }
    get capabilities() {
        if (this.isSessionConnected()) {
            return {
                subscribe: true,
                publish: this.openvidu.role !== 'SUBSCRIBER',
                forceUnpublish: this.openvidu.role === 'MODERATOR',
                forceDisconnect: this.openvidu.role === 'MODERATOR'
            };
        }
        return undefined;
    }
    /**
     * @hidden
     */
    get localParticipant() {
        return this.room.localParticipant;
    }
    constructor(openvidu) {
        super();
        /**
         * Collection of all StreamManagers of this Session ({@link Publisher} and {@link Subscriber})
         */
        this.streamManagers = [];
        /**
         * Map of remote connections in the session.
         * Key is the remote connection identifier
         */
        this.remoteConnections = new Map();
        // get streamManager(): StreamManager[] {}
        this.isRecorderParticipant = false;
        // Map to store the number of tracks for each participant
        this.participantLocalStreams = new Map();
        this.participantRemoteStreams = new Map();
        this.participantStreamsToSubscribe = new Map();
        this.IP_CAMERAS_STREAM_CREATED_TIMEOUT = window['IP_CAMERAS_STREAM_CREATED_TIMEOUT'] != null ? window['IP_CAMERAS_STREAM_CREATED_TIMEOUT'] : 3000;
        this.ipCamerasTimeouts = new Map();
        // This map for every remote participant allows keeping track and waiting:
        // - RoomEvent.ParticipantConnected (or RoomEvent.Connected => array Room.remoteParticipants)
        // - Custom signal for connectionCreated event, triggered after the update of Participant's metadata
        // After both events are received, the final "connectionCreated" event can be triggered
        this.LIVEKIT_EVENT_CUSTOM_SIGNAL = new Map();
        this.openvidu = openvidu;
        const roomOptions = {
        // adaptiveStream: true,
        // dynacast: true
        // audioCaptureDefaults: {
        // 	deviceId: audioDeviceId,
        // 	echoCancellation: true,
        // 	noiseSuppression: true,
        // 	autoGainControl: true
        // },
        // videoCaptureDefaults: {
        //     resolution: {
        //         width: 640,
        //         height: 480,
        //         frameRate: 30
        //     }
        // },
        // publishDefaults: {
        //     dtx: true,
        //     simulcast: true,
        //     stopMicTrackOnMute: true
        // },
        // stopLocalTrackOnUnpublish: true,
        // disconnectOnPageLeave: true
        };
        this.room = new livekit_client_1.Room(roomOptions);
    }
    /**
     * Connects to the session using `token`. Parameter `metadata` allows you to pass extra data to share with other users when
     * they receive `streamCreated` event. The structure of `metadata` string is up to you (maybe some standardized format
     * as JSON or XML is a good idea).
     *
     * This metadata is not considered secure, as it is generated in the client side. To pass secure data, add it as a parameter in the
     * token generation operation (through the API REST, openvidu-java-client or openvidu-node-client).
     *
     * Only after the returned Promise is successfully resolved {@link Session.connection} object will be available and properly defined.
     *
     * #### Events dispatched
     *
     * The {@link Session} object of the local participant will first dispatch one or more `connectionCreated` events upon successful termination of this method:
     * - First one for your own local Connection object, so you can retrieve {@link Session.connection} property.
     * - Then one for each remote Connection previously connected to the Session, if any. Any other remote user connecting to the Session after you have
     * successfully connected will also dispatch a `connectionCreated` event when they do so.
     *
     * The {@link Session} object of the local participant will also dispatch a `streamCreated` event for each remote active {@link Publisher} that was already streaming
     * when connecting, just after dispatching all remote `connectionCreated` events.
     *
     * The {@link Session} object of every other participant connected to the session will dispatch a `connectionCreated` event.
     *
     * See {@link ConnectionEvent} and {@link StreamEvent} to learn more.
     *
     * @returns A Promise to which you must subscribe that is resolved if the the connection to the Session was successful and rejected with an Error object if not
     *
     */
    connect(token, metadata) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                const { livekitUrl, shimUrl, livekitToken, role, roomSid, roomName, participantIdentity } = this.extractInfoFromOpenViduToken(token);
                this.openvidu.role = role;
                this.room.on(livekit_client_1.RoomEvent.Connected, this.handleRoomConnectedEvent.bind(this, resolve, livekitToken, metadata));
                this.room.on(livekit_client_1.RoomEvent.ParticipantConnected, this.handleParticipantConnectedEvent.bind(this));
                this.room.on(livekit_client_1.RoomEvent.MediaDevicesError, this.handleMediaDevicesErrorEvent.bind(this));
                this.room.on(livekit_client_1.RoomEvent.DataReceived, this.handleClientEvent.bind(this));
                this.room.on(livekit_client_1.RoomEvent.DataReceived, this.handleServerEvent.bind(this));
                this.room.on(livekit_client_1.RoomEvent.TrackMuted, this.handleTrackMutedUnmutedEvent.bind(this));
                this.room.on(livekit_client_1.RoomEvent.TrackUnmuted, this.handleTrackMutedUnmutedEvent.bind(this));
                this.room.on(livekit_client_1.RoomEvent.ParticipantMetadataChanged, this.handleParticipantMetadataChangedEvent.bind(this));
                this.room.on(livekit_client_1.RoomEvent.Disconnected, this.handleSessionDisconnectedEvent.bind(this));
                this.room.on(livekit_client_1.RoomEvent.ParticipantDisconnected, this.handleParticipantDisconnectedEvent.bind(this));
                this.room.on(livekit_client_1.RoomEvent.TrackUnpublished, this.handleTrackUnpublishedEvent.bind(this));
                this.room.on(livekit_client_1.RoomEvent.LocalTrackUnpublished, this.handleLocalTrackUnpublishedEvent.bind(this));
                this.room.on(livekit_client_1.RoomEvent.TrackSubscribed, this.handleTrackSubscribedEvent.bind(this));
                this.room.on(livekit_client_1.RoomEvent.TrackUnsubscribed, this.handleTrackUnsubscribedEvent.bind(this));
                this.room.on(livekit_client_1.RoomEvent.TrackPublished, this.handleTrackPublishedEvent.bind(this));
                if (!this.isRecorderParticipant) {
                    // Initialize the custom WebSocket when the participant is not a recorder
                    // Connect the custom WebSocket before connecting to the room.
                    // This ensures the Redis connection stores ip and platform before participantJoined webhook event
                    this.ws = new WebSocket_1.OvWebSocket(shimUrl, roomName, roomSid, participantIdentity, platform.getDescription());
                    yield this.ws.connect();
                }
                // Connect to the room
                const options = this.generateRoomConnectOptions();
                yield this.room.connect(livekitUrl, livekitToken, options);
            }
            catch (error) {
                logger.error(`Error connecting to ${platform.getName()} (version ${platform.getVersion()}) for ${platform.getFamily()}:`, error);
                reject(error);
                throw new Error(`Error connecting to session: ${error}`);
            }
        }));
    }
    /**
     * Leaves the session, destroying all streams and deleting the user as a participant.
     *
     * #### Events dispatched
     *
     * The {@link Session} object of the local participant will dispatch a `sessionDisconnected` event.
     * This event will automatically unsubscribe the leaving participant from every Subscriber object of the session (this includes closing the RTCPeerConnection and disposing all MediaStreamTracks)
     * and also deletes any HTML video element associated to each Subscriber (only those [created by OpenVidu Browser](/en/stable/cheatsheet/manage-videos/#let-openvidu-take-care-of-the-video-players)).
     * For every video removed, each Subscriber object will dispatch a `videoElementDestroyed` event.
     * Call `event.preventDefault()` upon event `sessionDisconnected` to avoid this behavior and take care of disposing and cleaning all the Subscriber objects yourself.
     * See {@link SessionDisconnectedEvent} and {@link VideoElementEvent} to learn more.
     *
     * The {@link Publisher} object of the local participant will dispatch a `streamDestroyed` event if there is a {@link Publisher} object publishing to the session.
     * This event will automatically stop all media tracks and delete any HTML video element associated to it (only those [created by OpenVidu Browser](/en/stable/cheatsheet/manage-videos/#let-openvidu-take-care-of-the-video-players)).
     * For every video removed, the Publisher object will dispatch a `videoElementDestroyed` event.
     * Call `event.preventDefault()` upon event `streamDestroyed` if you want to clean the Publisher object on your own or re-publish it in a different Session (to do so it is a mandatory requirement to call `Session.unpublish()`
     * or/and `Session.disconnect()` in the previous session). See {@link StreamEvent} and {@link VideoElementEvent} to learn more.
     *
     * The {@link Session} object of every other participant connected to the session will dispatch a `streamDestroyed` event if the disconnected participant was publishing.
     * This event will automatically unsubscribe the Subscriber object from the session (this includes closing the RTCPeerConnection and disposing all MediaStreamTracks)
     * and also deletes any HTML video element associated to that Subscriber (only those [created by OpenVidu Browser](/en/stable/cheatsheet/manage-videos/#let-openvidu-take-care-of-the-video-players)).
     * For every video removed, the Subscriber object will dispatch a `videoElementDestroyed` event.
     * Call `event.preventDefault()` upon event `streamDestroyed` to avoid this default behavior and take care of disposing and cleaning the Subscriber object yourself.
     * See {@link StreamEvent} and {@link VideoElementEvent} to learn more.
     *
     * The {@link Session} object of every other participant connected to the session will dispatch a `connectionDestroyed` event in any case. See {@link ConnectionEvent} to learn more.
     */
    disconnect() {
        if (this.connection && this.room) {
            this.room
                .disconnect()
                .then(() => {
                var _a;
                const reason = 'disconnect';
                this.connection.stream.ee.emitEvent('local-stream-destroyed', [reason]);
                (_a = this.ws) === null || _a === void 0 ? void 0 : _a.close();
                this.ws = undefined;
            })
                .catch(() => {
                logger.warn('Error disconnecting from the session ' + this.sessionId);
            });
        }
        else {
            logger.warn('You were not connected to the session ' + this.sessionId);
        }
    }
    /**
     * @hidden
     */
    isSessionConnected() {
        if (!this.room)
            return false;
        return this.room.state === livekit_client_1.ConnectionState.Connected;
    }
    /**
     * Subscribes to a `stream`, adding a new HTML video element to DOM with `subscriberProperties` settings. This method is usually called in the callback of `streamCreated` event.
     *
     * #### Events dispatched
     *
     * The {@link Subscriber} object will dispatch a `videoElementCreated` event once the HTML video element has been added to DOM (only if you
     * [let OpenVidu take care of the video players](/en/stable/cheatsheet/manage-videos/#let-openvidu-take-care-of-the-video-players)). See {@link VideoElementEvent} to learn more.
     *
     * The {@link Subscriber} object will dispatch a `streamPlaying` event once the remote stream starts playing. See {@link StreamManagerEvent} to learn more.
     *
     * @param stream Stream object to subscribe to
     * @param targetElement HTML DOM element (or its `id` attribute) in which the video element of the Subscriber will be inserted (see {@link SubscriberProperties.insertMode}). If *null* or *undefined* no default video will be created for this Subscriber.
     * You can always call method {@link Subscriber.addVideoElement} or {@link Subscriber.createVideoElement} to manage the video elements on your own (see [Manage video players](/en/stable/cheatsheet/manage-videos) section)
     * @param completionHandler `error` parameter is null if `subscribe` succeeds, and is defined if it fails.
     */
    subscribe(stream, targetElement, param3, param4) {
        const properties = this.processAndGetSubscriberProperties(param3);
        let completionHandler = () => { };
        if (!!param3 && typeof param3 === 'function') {
            completionHandler = param3;
        }
        else if (!!param4) {
            completionHandler = param4;
        }
        if (!this.isSessionConnected()) {
            completionHandler(this.notConnectedError());
            throw this.notConnectedError();
        }
        logger.info('Subscribing to ' + stream.connection.connectionId);
        const participant = stream.connection.participant;
        let tracksToSubscribe;
        if (this.isIpCam(participant)) {
            // Simply subscribe to all tracks
            tracksToSubscribe = participant.getTrackPublications();
        }
        else {
            // Get track publications mixing 3 things: the available tracks in the participant, the specific track ids, and the desired kind of tracks to subscribe
            tracksToSubscribe = participant.getTrackPublications().filter((publication) => {
                const shouldSubscribeToTrack = (publication.kind === livekit_client_1.Track.Kind.Audio && properties.subscribeToAudio && stream.streamId === publication.trackName) ||
                    (publication.kind === livekit_client_1.Track.Kind.Video && properties.subscribeToVideo && stream.streamId === publication.trackName);
                return shouldSubscribeToTrack;
            });
        }
        const subscriber = new Subscriber_1.Subscriber(stream, targetElement, properties);
        // Subscribe to each track
        tracksToSubscribe.forEach((publication) => publication.setSubscribed(true));
        if (!!subscriber.targetElement) {
            stream.streamManager.lazyLaunchVideoElementCreatedEvent = true;
            stream.streamManager.createVideoElement(subscriber.targetElement, properties.insertMode);
        }
        completionHandler(undefined);
        return subscriber;
    }
    subscribeAsync(stream, targetElement, properties) {
        try {
            if (!!properties) {
                return Promise.resolve(this.subscribe(stream, targetElement, properties));
            }
            else {
                return Promise.resolve(this.subscribe(stream, targetElement));
            }
        }
        catch (error) {
            return Promise.reject(error);
        }
    }
    /**
     * Unsubscribes from `subscriber`, automatically removing its associated HTML video elements.
     *
     * #### Events dispatched
     *
     * The {@link Subscriber} object will dispatch a `videoElementDestroyed` event for each video associated to it that was removed from DOM.
     * Only videos [created by OpenVidu Browser](/en/stable/cheatsheet/manage-videos/#let-openvidu-take-care-of-the-video-players)) will be automatically removed
     *
     * See {@link VideoElementEvent} to learn more
     */
    unsubscribe(subscriber) {
        if (!this.isSessionConnected()) {
            return Promise.reject(this.notConnectedError());
        }
        const connectionId = subscriber.stream.connection.connectionId;
        logger.info('Unsubscribing from ' + connectionId);
        subscriber.unsubscribe();
        subscriber.stream.streamManager.removeAllVideos();
        logger.info('Unsubscribed correctly from ' + connectionId);
        return Promise.resolve();
    }
    /**
     * Publishes to the Session the Publisher object
     *
     * #### Events dispatched
     *
     * The local {@link Publisher} object will dispatch a `streamCreated` event upon successful termination of this method. See {@link StreamEvent} to learn more.
     *
     * The local {@link Publisher} object will dispatch a `streamPlaying` once the media stream starts playing. See {@link StreamManagerEvent} to learn more.
     *
     * The {@link Session} object of every other participant connected to the session will dispatch a `streamCreated` event so they can subscribe to it. See {@link StreamEvent} to learn more.
     *
     * @returns A Promise (to which you can optionally subscribe to) that is resolved only after the publisher was successfully published and rejected with an Error object if not
     */
    publish(publisher) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isSessionConnected()) {
                return Promise.reject(this.notConnectedError());
            }
            publisher.session = this;
            publisher.stream.session = this;
            publisher.stream.connection = this.connection;
            this.connection.stream = publisher.stream;
            // Publisher was unpublished. Must reinitialize
            if (publisher.shouldReinitializePublisher) {
                publisher.setupReadyToAttachListener();
                yield publisher.initialize();
                publisher.shouldReinitializePublisher = false;
            }
            yield publisher.stream.publish();
            // Store the local stream
            const { videoTrackId, audioTrackId, audioActive, videoActive } = this.getTrackIdsFromStreamId(publisher.stream.streamId);
            const localStream = {
                streamId: publisher.stream.streamId,
                stream: publisher.stream,
                videoId: videoTrackId,
                videoActive,
                audioId: audioTrackId,
                audioActive
            };
            if (publisher.stream.videoTrack) {
                const tr = {
                    id: `${publisher.stream.videoTrack.kind}:${publisher.stream.videoTrack.source}`,
                    kind: publisher.stream.videoTrack.kind,
                    source: publisher.stream.videoTrack.source,
                    trackPublishedEventReceived: false,
                    trackUnpublishedEventReceived: false,
                    trackSubscribedEventReceived: false,
                    localTrackUnpublishedEventReceived: false
                };
                localStream[livekit_client_1.Track.Kind.Video] = tr;
            }
            if (publisher.stream.audioTrack) {
                const tr = {
                    id: `${publisher.stream.audioTrack.kind}:${publisher.stream.audioTrack.source}`,
                    kind: publisher.stream.audioTrack.kind,
                    source: publisher.stream.audioTrack.source,
                    trackPublishedEventReceived: false,
                    trackUnpublishedEventReceived: false,
                    trackSubscribedEventReceived: false,
                    localTrackUnpublishedEventReceived: false
                };
                localStream[livekit_client_1.Track.Kind.Audio] = tr;
            }
            this.participantLocalStreams.set(localStream.streamId, localStream);
            // Emit streamCreated event from the Publisher object
            const streamEventPublisher = new StreamEvent_1.StreamEvent(false, publisher, 'streamCreated', publisher.stream, '');
            publisher.publicEmmiter.emitEvent('streamCreated', [streamEventPublisher]);
            if (this.room.isRecording) {
                /**
                 * Send event to openvidu-server-shim to notify that a new participant has been published
                 * for checking if it should be recorded
                 */
                (_a = this.ws) === null || _a === void 0 ? void 0 : _a.emitEvent(InternalSignalTypes_1.InternalSignalType.OPENVIDU_PARTICIPANT_PUBLISHED, {
                    identity: this.localParticipant.identity,
                    roomName: this.room.name
                });
            }
        });
    }
    /**
     * Unpublishes from the Session the Publisher object.
     *
     * #### Events dispatched
     *
     * The {@link Publisher} object of the local participant will dispatch a `streamDestroyed` event.
     * This event will automatically stop all media tracks and delete any HTML video element associated to this Publisher
     * (only those videos [created by OpenVidu Browser](/en/stable/cheatsheet/manage-videos/#let-openvidu-take-care-of-the-video-players)).
     * For every video removed, the Publisher object will dispatch a `videoElementDestroyed` event.
     * Call `event.preventDefault()` upon event `streamDestroyed` if you want to clean the Publisher object on your own or re-publish it in a different Session.
     *
     * The {@link Session} object of every other participant connected to the session will dispatch a `streamDestroyed` event.
     * This event will automatically unsubscribe the Subscriber object from the session (this includes closing the RTCPeerConnection and disposing all MediaStreamTracks) and
     * delete any HTML video element associated to it (only those [created by OpenVidu Browser](/en/stable/cheatsheet/manage-videos/#let-openvidu-take-care-of-the-video-players)).
     * For every video removed, the Subscriber object will dispatch a `videoElementDestroyed` event.
     * Call `event.preventDefault()` upon event `streamDestroyed` to avoid this default behavior and take care of disposing and cleaning the Subscriber object on your own.
     *
     * See {@link StreamEvent} and {@link VideoElementEvent} to learn more.
     */
    unpublish(publisher) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isSessionConnected()) {
                return Promise.reject(this.notConnectedError());
            }
            const promises = [];
            for (let track of this.localParticipant.getTrackPublications()) {
                if (track.track) {
                    promises.push(this.localParticipant.unpublishTrack(track.track, true));
                }
            }
            yield Promise.all(promises);
            publisher.shouldReinitializePublisher = true;
        });
    }
    forceDisconnect(connection) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            var _a;
            if (!this.isSessionConnected()) {
                reject(this.notConnectedError());
            }
            if (!this.capabilities.forceDisconnect) {
                reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.OPENVIDU_PERMISSION_DENIED, "You don't have permissions to force a disconnection"));
            }
            (_a = this.ws) === null || _a === void 0 ? void 0 : _a.requestAnswer(InternalSignalTypes_1.InternalSignalType.OPENVIDU_FORCE_DISCONNECT, {
                identity: connection.connectionId,
                roomName: this.room.name,
                roomSid: yield this.room.getSid()
            }, (err, res) => {
                if (err)
                    reject(err);
                if (res === null || res === void 0 ? void 0 : res.error) {
                    if (res.code === 401) {
                        reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.OPENVIDU_PERMISSION_DENIED, res.error));
                    }
                    else {
                        reject(res);
                    }
                }
                resolve();
            });
        }));
    }
    forceUnpublish(stream) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            var _a;
            if (!this.isSessionConnected()) {
                reject(this.notConnectedError());
            }
            if (!this.capabilities.forceDisconnect) {
                reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.OPENVIDU_PERMISSION_DENIED, "You don't have permissions to force a disconnection"));
            }
            (_a = this.ws) === null || _a === void 0 ? void 0 : _a.requestAnswer(InternalSignalTypes_1.InternalSignalType.OPENVIDU_FORCE_UNPUBLISH, {
                identity: stream.connection.connectionId,
                roomName: this.room.name,
                roomSid: yield this.room.getSid()
            }, (err, res) => {
                if (err)
                    reject(err);
                if (res === null || res === void 0 ? void 0 : res.error) {
                    if (res.code === 401) {
                        reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.OPENVIDU_PERMISSION_DENIED, res.error));
                    }
                    else {
                        reject(res);
                    }
                }
                resolve();
            });
        }));
    }
    /**
     * @hidden
     */
    parseSignalMessage(signal) {
        const signalMessage = {
            to: [],
            data: signal.data ? signal.data : '',
            type: signal.type ? signal.type : 'signal'
        };
        if (signal.to && signal.to.length > 0) {
            const connectionIds = signal.to.map((connection) => connection.connectionId);
            signalMessage['to'] = connectionIds;
        }
        return signalMessage;
    }
    /**
     * Sends one signal. `signal` object has the following optional properties:
     * ```json
     * {data:string, to:Connection[], type:string}
     * ```
     * All users subscribed to that signal (`session.on('signal:type', ...)` or `session.on('signal', ...)` for all signals) and whose Connection objects are in `to` array will receive it. Their local
     * Session objects will dispatch a `signal` or `signal:type` event. See {@link SignalEvent} to learn more.
     *
     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the message successfully reached openvidu-server and rejected with an Error object if not. _This doesn't
     * mean that openvidu-server could resend the message to all the listed receivers._
     */
    signal(signal) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.signalInternal(signal, true);
                const signalMessage = this.parseSignalMessage(signal);
                this.emitSignalEventIfNecessary(signalMessage, this.connection);
            }
            catch (error) {
                throw new Error('Error sending signal: ' + error);
            }
        });
    }
    /**
     * @hidden
     */
    signalInternal(signal, sendWebsocket) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isSessionConnected()) {
                logger.error('Error sending signal: session is not connected');
                return Promise.reject(this.notConnectedError());
            }
            const data = new TextEncoder().encode(signal.data);
            const destinationIdentities = signal.to ? signal.to.map((connection) => connection.connectionId) : [];
            const publishOptions = {
                topic: signal.type,
                destinationIdentities,
                reliable: true
            };
            yield this.room.localParticipant.publishData(data, publishOptions);
            if (sendWebsocket) {
                const data = Object.assign(Object.assign({}, signal), { to: destinationIdentities, session: this.sessionId, uniqueSessionId: yield this.room.getSid(), from: this.localParticipant.identity });
                (_a = this.ws) === null || _a === void 0 ? void 0 : _a.emitEvent(InternalSignalTypes_1.InternalSignalType.OPENVIDU_SIGNAL, data);
            }
        });
    }
    emitSignalEventIfNecessary(signalMessage, from) {
        if (!signalMessage.to || signalMessage.to.length === 0 || signalMessage.to.includes(this.localParticipant.identity)) {
            // The signal is meant for the local participant
            const strippedType = signalMessage.type === 'signal' ? undefined : signalMessage.type.replace(/^(signal:)/, '');
            const event = new SignalEvent_1.SignalEvent(this, strippedType, signalMessage.data, from);
            this.publicEmmiter.emitEvent('signal', [event]);
            if (strippedType) {
                this.publicEmmiter.emitEvent('signal:' + strippedType, [event]);
            }
        }
    }
    /**
     * See {@link EventDispatcher.on}
     */
    on(type, handler) {
        var _a, _b, _c, _d;
        super.onAux(type, "Event '" + type + "' triggered by 'Session'", handler);
        switch (type) {
            case 'connectionCreated':
                break;
            case 'connectionDestroyed':
                break;
            case 'connectionPropertyChanged':
                break;
            case 'sessionDisconnected':
                break;
            case 'streamCreated':
                break;
            case 'streamDestroyed':
                break;
            case 'recordingStarted':
                break;
            case 'recordingStopped':
                break;
            case 'broadcastStarted':
                break;
            case 'broadcastStopped':
                break;
            case 'networkQualityLevelChanged':
                this.room.on(livekit_client_1.RoomEvent.ConnectionQualityChanged, this.handleNetworkQualityLevelChanged.bind(this));
                break;
            case 'reconnecting':
                this.room.on(livekit_client_1.RoomEvent.Reconnecting, () => this.publicEmmiter.emitEvent('reconnecting', []));
                break;
            case 'reconnected':
                this.room.on(livekit_client_1.RoomEvent.Reconnected, () => this.publicEmmiter.emitEvent('reconnected', []));
                break;
            case 'publisherStartSpeaking':
                // If there are already available remote streams with audio, enable hark 'speaking' event in all of them
                this.remoteConnections.forEach((remoteConnection) => {
                    var _a;
                    if (!!((_a = remoteConnection.stream) === null || _a === void 0 ? void 0 : _a.hasAudio)) {
                        remoteConnection.stream.enableHarkSpeakingEvent();
                    }
                });
                if (!!((_b = (_a = this.connection) === null || _a === void 0 ? void 0 : _a.stream) === null || _b === void 0 ? void 0 : _b.hasAudio)) {
                    // If connected to the Session and publishing with audio, also enable hark 'speaking' event for the Publisher
                    this.connection.stream.enableHarkSpeakingEvent();
                }
                break;
            case 'publisherStopSpeaking':
                // If there are already available remote streams with audio, enable hark 'stopped_speaking' event in all of them
                this.remoteConnections.forEach((remoteConnection) => {
                    var _a;
                    if (!!((_a = remoteConnection.stream) === null || _a === void 0 ? void 0 : _a.hasAudio)) {
                        remoteConnection.stream.enableHarkStoppedSpeakingEvent();
                    }
                });
                if (!!((_d = (_c = this.connection) === null || _c === void 0 ? void 0 : _c.stream) === null || _d === void 0 ? void 0 : _d.hasAudio)) {
                    // If connected to the Session and publishing with audio, also enable hark 'stopped_speaking' event for the Publisher
                    this.connection.stream.enableHarkStoppedSpeakingEvent();
                }
                break;
            case 'signal':
                break;
            // case 'speechToTextMessage':
            //     break;
            // case 'exception':
            //     logger.warn('exception event not implemented in SessionAdapter');
            //     break;
        }
        return this;
    }
    /**
     * See {@link EventDispatcher.once}
     */
    once(type, handler) {
        var _a, _b, _c, _d;
        super.onceAux(type, "Event '" + type + "' triggered by 'Session'", handler);
        switch (type) {
            case 'connectionCreated':
                break;
            case 'connectionDestroyed':
                break;
            case 'connectionPropertyChanged':
                break;
            case 'sessionDisconnected':
                break;
            case 'streamCreated':
                break;
            case 'streamDestroyed':
                break;
            case 'recordingStarted':
                break;
            case 'recordingStopped':
                break;
            case 'broadcastStarted':
                break;
            case 'broadcastStopped':
                break;
            case 'networkQualityLevelChanged':
                this.room.once(livekit_client_1.RoomEvent.ConnectionQualityChanged, this.handleNetworkQualityLevelChanged.bind(this));
                break;
            case 'reconnecting':
                this.room.once(livekit_client_1.RoomEvent.Reconnecting, () => this.publicEmmiter.emitEvent('reconnecting', []));
                break;
            case 'reconnected':
                this.room.once(livekit_client_1.RoomEvent.Reconnected, () => this.publicEmmiter.emitEvent('reconnected', []));
                break;
            case 'publisherStartSpeaking':
                // If there are already available remote streams with audio, enable hark 'speaking' event (once) in all of them once
                this.remoteConnections.forEach((remoteConnection) => {
                    var _a;
                    if (!!((_a = remoteConnection.stream) === null || _a === void 0 ? void 0 : _a.hasAudio)) {
                        remoteConnection.stream.enableOnceHarkSpeakingEvent();
                    }
                });
                if (!!((_b = (_a = this.connection) === null || _a === void 0 ? void 0 : _a.stream) === null || _b === void 0 ? void 0 : _b.hasAudio)) {
                    // If connected to the Session and publishing with audio, also enable hark 'speaking' event (once) for the Publisher
                    this.connection.stream.enableOnceHarkSpeakingEvent();
                }
                break;
            case 'publisherStopSpeaking':
                // If there are already available remote streams with audio, enable hark 'stopped_speaking' event (once) in all of them once
                this.remoteConnections.forEach((remoteConnection) => {
                    var _a;
                    if (!!((_a = remoteConnection.stream) === null || _a === void 0 ? void 0 : _a.hasAudio)) {
                        remoteConnection.stream.enableOnceHarkStoppedSpeakingEvent();
                    }
                });
                if (!!((_d = (_c = this.connection) === null || _c === void 0 ? void 0 : _c.stream) === null || _d === void 0 ? void 0 : _d.hasAudio)) {
                    // If connected to the Session and publishing with audio, also enable hark 'stopped_speaking' event (once) for the Publisher
                    this.connection.stream.enableOnceHarkStoppedSpeakingEvent();
                }
                break;
            case 'signal':
                break;
            // case 'speechToTextMessage':
            //     break;
            // case 'exception':
            //     logger.warn('exception event not implemented in SessionAdapter');
            //     break;
        }
        return this;
    }
    /**
     * See {@link EventDispatcher.off}
     */
    off(type, handler) {
        var _a, _b, _c, _d;
        super.offAux(type, handler);
        switch (type) {
            case 'connectionCreated':
                break;
            case 'connectionDestroyed':
                break;
            case 'connectionPropertyChanged':
                break;
            case 'sessionDisconnected':
                break;
            case 'streamCreated':
                break;
            case 'streamDestroyed':
                break;
            case 'recordingStarted':
                break;
            case 'recordingStopped':
                break;
            case 'broadcastStarted':
                break;
            case 'broadcastStopped':
                break;
            case 'networkQualityLevelChanged':
                this.room.off(livekit_client_1.RoomEvent.ConnectionQualityChanged, this.handleNetworkQualityLevelChanged.bind(this));
                break;
            case 'reconnecting':
                this.room.off(livekit_client_1.RoomEvent.Reconnecting, () => this.publicEmmiter.emitEvent('reconnecting', []));
                break;
            case 'reconnected':
                this.room.off(livekit_client_1.RoomEvent.Reconnected, () => this.publicEmmiter.emitEvent('reconnected', []));
                break;
            case 'publisherStartSpeaking':
                // Check if Session object still has some listener for the event
                if (!this.anySpeechEventListenerEnabled('publisherStartSpeaking', false)) {
                    this.remoteConnections.forEach((remoteConnection) => {
                        var _a;
                        if (!!((_a = remoteConnection.stream) === null || _a === void 0 ? void 0 : _a.streamManager)) {
                            // Check if Subscriber object still has some listener for the event
                            if (!remoteConnection.stream.streamManager.anySpeechEventListenerEnabled('publisherStartSpeaking', false)) {
                                remoteConnection.stream.disableHarkSpeakingEvent(false);
                            }
                        }
                    });
                    if (!!((_b = (_a = this.connection) === null || _a === void 0 ? void 0 : _a.stream) === null || _b === void 0 ? void 0 : _b.streamManager)) {
                        // Check if Publisher object still has some listener for the event
                        if (!this.connection.stream.streamManager.anySpeechEventListenerEnabled('publisherStartSpeaking', false)) {
                            this.connection.stream.disableHarkSpeakingEvent(false);
                        }
                    }
                }
                break;
            case 'publisherStopSpeaking':
                // Check if Session object still has some listener for the event
                if (!this.anySpeechEventListenerEnabled('publisherStopSpeaking', false)) {
                    this.remoteConnections.forEach((remoteConnection) => {
                        var _a;
                        if (!!((_a = remoteConnection.stream) === null || _a === void 0 ? void 0 : _a.streamManager)) {
                            // Check if Subscriber object still has some listener for the event
                            if (!remoteConnection.stream.streamManager.anySpeechEventListenerEnabled('publisherStopSpeaking', false)) {
                                remoteConnection.stream.disableHarkStoppedSpeakingEvent(false);
                            }
                        }
                    });
                    if (!!((_d = (_c = this.connection) === null || _c === void 0 ? void 0 : _c.stream) === null || _d === void 0 ? void 0 : _d.streamManager)) {
                        // Check if Publisher object still has some listener for the event
                        if (!this.connection.stream.streamManager.anySpeechEventListenerEnabled('publisherStopSpeaking', false)) {
                            this.connection.stream.disableHarkStoppedSpeakingEvent(false);
                        }
                    }
                }
                break;
            case 'signal':
                break;
            // case 'speechToTextMessage':
            //     break;
            // case 'exception':
            //     logger.warn('exception event not implemented in SessionAdapter');
            //     break;
        }
        return this;
    }
    /**
     * ! Not supported in adapter
     * Subscribe to the Speech-To-Text events for this {@link Stream}. The Session object will emit {@link SpeechToTextEvent} for the Stream
     * when speech is detected in its audio track.
     *
     * @param stream - The Stream for which you want to start receiving {@link SpeechToTextEvent}.
     * @param lang - The language of the Stream's audio track. It must be a valid [BCP-47](https://tools.ietf.org/html/bcp47) language tag like "en-US" or "es-ES".
     *
     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the speech-to-text subscription
     * was successful and rejected with an Error object if not.
     */
    subscribeToSpeechToText(stream, lang) {
        throw new Error("'subscribeToSpeechToText' method is not ready yet.");
    }
    /**
     * ! Not supported in adapter
     * Unsubscribe from the Speech-To-Text events for this {@link Stream}.
     *
     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the speech-to-text subscription
     * was successful and rejected with an Error object if not.
     */
    unsubscribeFromSpeechToText(stream) {
        throw new Error("'unsubscribeFromSpeechToText' method is not ready yet.");
    }
    extractInfoFromOpenViduToken(token) {
        if (!token)
            throw new Error('Trying to get room metadata from an empty token');
        try {
            const url = new URL(token);
            this.isRecorderParticipant = url.searchParams.get('recorder') === 'true';
            let livekitToken = null;
            if (this.isRecorderParticipant) {
                livekitToken = egress_sdk_1.default.getAccessToken();
            }
            else {
                livekitToken = url.searchParams.get('token');
            }
            if (!livekitToken)
                throw new Error('Token does not contain livekit token');
            const base64Url = livekitToken.split('.')[1];
            const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
            const jsonPayload = decodeURIComponent(window
                .atob(base64)
                .split('')
                .map((c) => {
                return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
            })
                .join(''));
            const payload = JSON.parse(jsonPayload);
            if (payload.kind === 'egress' && this.isRecorderParticipant) {
                const { video, sub: identity } = payload;
                return {
                    livekitUrl: egress_sdk_1.default.getLiveKitURL(),
                    livekitToken,
                    shimUrl: '',
                    role: 'SUBSCRIBER',
                    roomSid: video.room,
                    roomName: video.room,
                    participantIdentity: identity
                };
            }
            if (!(payload === null || payload === void 0 ? void 0 : payload.metadata))
                throw new Error('Token does not contain metadata');
            const { livekitUrl, openviduShimUrl, role, roomSid, roomName, participantIdentity } = JSON.parse(payload.metadata);
            return { livekitUrl, shimUrl: openviduShimUrl, livekitToken, role, roomSid, roomName, participantIdentity };
        }
        catch (error) {
            throw new Error('Error decoding and parsing token: ' + error);
        }
    }
    handleMediaDevicesErrorEvent(error) {
        var _a, _b;
        if ((_b = (_a = this.connection) === null || _a === void 0 ? void 0 : _a.stream) === null || _b === void 0 ? void 0 : _b.streamManager) {
            this.connection.stream.streamManager.emitEvent('accessDenied', [livekit_client_1.MediaDeviceFailure.getFailure(error)]);
        }
    }
    /**
     * Sends a custom connection created event to remote connections.
     * This custom event is used to notify other participants that a new connection has been created after local participant
     * metadata has been updated.
     *
     * @remarks
     * This method sends a custom connection created event to the server.
     *
     * @returns A promise that resolves when the event is sent successfully.
     */
    sendCustomConnectionCreatedSignal(to) {
        return __awaiter(this, void 0, void 0, function* () {
            const connections = to.map((identity) => {
                if (this.remoteConnections.has(identity)) {
                    return this.remoteConnections.get(identity);
                }
                else {
                    // Fake auxiliar Connection objects. Only purpose is to be able to call this.signalInternal
                    const connectionAux = new Connection_1.Connection(this, new livekit_client_1.RemoteParticipant(undefined, identity), undefined);
                    connectionAux.connectionId = identity;
                    return connectionAux;
                }
            });
            const signal = {
                data: JSON.stringify({ sentFromServer: false, payload: { participantIdentity: this.room.localParticipant.identity } }),
                to: connections,
                type: `${InternalSignalTypes_1.InternalSignalType.CUSTOM_CLIENT_SIGNAL_PREFIX}${InternalSignalTypes_1.InternalSignalType.OPENVIDU_CONNECTION_CREATED}`
            };
            yield this.signalInternal(signal, false);
        });
    }
    handleRoomConnectedEvent(resolve, token, participantMetadata) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this.connection = new Connection_1.Connection(this, this.room.localParticipant);
            this.openvidu.finalUserId = (_a = this.room.localParticipant) === null || _a === void 0 ? void 0 : _a.identity;
            this.token = token;
            if (this.isRecorderParticipant) {
                egress_sdk_1.default.setRoom(this.room);
                egress_sdk_1.default.startRecording();
                yield this.processSessionConnected();
                return resolve();
            }
            const updatedMetadata = this.processClientMetadata(participantMetadata);
            if (updatedMetadata) {
                // Update the metadata of the local participant
                // Resolve the promise when the metadata is updated
                this.room.localParticipant.once(livekit_client_1.ParticipantEvent.ParticipantMetadataChanged, () => __awaiter(this, void 0, void 0, function* () {
                    this.connection.updatePropertiesFromMetadata(updatedMetadata);
                    yield this.processSessionConnected();
                    return resolve();
                }));
                return yield this.room.localParticipant.setMetadata(updatedMetadata);
            }
            else {
                yield this.processSessionConnected();
                return resolve();
            }
        });
    }
    handleParticipantMetadataChangedEvent(prevMetadata, participant) {
        if (participant.identity === this.room.localParticipant.identity) {
            if (!this.connection) {
                // The local connection has not been created yet. Event RoomConnected still not processed
                return;
            }
            // Local participant metadata has been updated. ConnectionPropertyChanged events
            const metadata = JSON.parse(participant.metadata);
            const newRole = metadata.role;
            if (newRole !== this.openvidu.role) {
                const lastRole = this.openvidu.role;
                this.openvidu.role = newRole;
                this.connection.role = newRole;
                const connectionEvent = new ConnectionPropertyChangedEvent_1.ConnectionPropertyChangedEvent(this, this.connection, 'role', this.connection.role, lastRole);
                this.publicEmmiter.emitEvent('connectionPropertyChanged', [connectionEvent]);
            }
            const newRecord = metadata.record;
            if (newRecord !== this.connection.record) {
                const lastRecord = this.connection.record;
                this.connection.record = newRecord;
                const connectionEvent = new ConnectionPropertyChangedEvent_1.ConnectionPropertyChangedEvent(this, this.connection, 'record', this.connection.record, lastRecord);
                this.publicEmmiter.emitEvent('connectionPropertyChanged', [connectionEvent]);
            }
        }
        else {
            // Remote participant metadata has been updated
            const connection = this.remoteConnections.get(participant.identity);
            if (!connection) {
                logger.warn(`Connection ${participant.identity} not found`);
                return;
            }
            const metadata = JSON.parse(participant.metadata);
            if (metadata.role !== null) {
                connection.role = metadata.role;
            }
            if (metadata.record !== null) {
                connection.record = metadata.record;
            }
        }
    }
    /**
     * Processes the session connected event.
     * Initializes remote connections and emits corresponding events.
     */
    processSessionConnected() {
        return __awaiter(this, void 0, void 0, function* () {
            // Local 'connectionCreated' event
            this.publicEmmiter.emitEvent('connectionCreated', [new ConnectionEvent_1.ConnectionEvent(false, this, 'connectionCreated', this.connection, '')]);
            const remoteParticipants = this.room.remoteParticipants;
            const connectionPromises = [];
            // Handle existing participants
            const remoteParticipantsArray = Array.from(remoteParticipants.values());
            for (const remoteParticipant of remoteParticipantsArray) {
                let connection = this.remoteConnections.get(remoteParticipant.identity);
                if (!connection) {
                    connection = new Connection_1.Connection(this, remoteParticipant);
                    this.remoteConnections.set(connection.connectionId, connection);
                }
                const promise = (() => __awaiter(this, void 0, void 0, function* () {
                    yield this.handleParticipantConnectedEvent(remoteParticipant);
                    // Simulate a TrackPublished event for each existing track publication of the participant
                    if (remoteParticipant.trackPublications.size > 0) {
                        remoteParticipant.getTrackPublications().forEach((publication) => {
                            this.handleTrackPublishedEvent(publication, remoteParticipant);
                        });
                    }
                }))();
                // Add the promise to the list of connection promises
                connectionPromises.push(promise);
            }
            yield Promise.all(connectionPromises);
        });
    }
    /**
     * Handles the room data received event.
     * It is also used for receiving internal events from other participants.
     * If the event is a signal event, it is emitted to the public emmiter.
     *
     * @param payload - The payload data received.
     * @param participant - The participant associated with the event.
     * @param kind - The kind of data packet.
     * @param topic - The topic of the event.
     */
    handleClientEvent(payload, participant, kind, topic) {
        var _a;
        const strData = this.decodeData(payload);
        let dataObj;
        try {
            dataObj = JSON.parse(strData);
        }
        catch (error) {
            // If the data is not a JSON, it is a string
            dataObj = strData;
        }
        if (dataObj.sentFromServer)
            return;
        const eventInfo = dataObj.payload;
        let connection;
        const participantIdentity = (_a = participant === null || participant === void 0 ? void 0 : participant.identity) !== null && _a !== void 0 ? _a : eventInfo === null || eventInfo === void 0 ? void 0 : eventInfo.participantIdentity;
        switch (topic) {
            case `${InternalSignalTypes_1.InternalSignalType.CUSTOM_CLIENT_SIGNAL_PREFIX}${InternalSignalTypes_1.InternalSignalType.OPENVIDU_STREAM_PROPERTY_CHANGED}`:
                const { changedProperty, newValue, oldValue, reason } = eventInfo;
                connection = this.remoteConnections.get(participantIdentity);
                if (!connection) {
                    logger.error(`No connection found for remote participant ${participantIdentity} when processing streamPropertyChanged event`);
                    return;
                }
                // Emit event from session
                const sessionEvent = new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(connection.session, connection.stream, changedProperty, newValue, oldValue, reason);
                this.publicEmmiter.emitEvent('streamPropertyChanged', [sessionEvent]);
                // Emit event from StreamManager
                if (connection.stream.streamManager) {
                    const streamManagerEvent = new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(connection.stream.streamManager, connection.stream, changedProperty, newValue, oldValue, reason);
                    connection.stream.streamManager.emitEvent('streamPropertyChanged', [streamManagerEvent]);
                }
                break;
            case `${InternalSignalTypes_1.InternalSignalType.CUSTOM_CLIENT_SIGNAL_PREFIX}${InternalSignalTypes_1.InternalSignalType.OPENVIDU_CONNECTION_CREATED}`:
                // Custom signal event after local participant metadata has been updated
                // Check if the local participant has already received the two necessary events for this remote participant
                if (!this.LIVEKIT_EVENT_CUSTOM_SIGNAL.has(participantIdentity)) {
                    // First time local participant knows about this remote participant
                    this.LIVEKIT_EVENT_CUSTOM_SIGNAL.set(participantIdentity, { livekit: false, custom: true });
                }
                else {
                    // Local participant already knows about this remote participant. LiveKit event already received
                    const events = this.LIVEKIT_EVENT_CUSTOM_SIGNAL.get(participantIdentity);
                    events.custom = true;
                    if (events.livekit && events.custom) {
                        this.connectionCreatedEventReady(participant);
                    }
                    else {
                        // This should never happen. If there is an element in the map, it means the livekit event has to be received
                        console.error('Unknown error. LiveKit event not received in local participant ' +
                            this.room.localParticipant.identity +
                            ' for remote participant ' +
                            participant.identity);
                    }
                }
                break;
            default:
                // Regular 'signal' events
                connection = this.remoteConnections.get(participantIdentity);
                this.emitSignalEventIfNecessary({ data: strData, type: topic || '', to: [] }, connection);
                break;
        }
    }
    processAndGetSubscriberProperties(param3) {
        const defaultProperties = {
            insertMode: VideoInsertMode_1.VideoInsertMode.APPEND,
            subscribeToAudio: true,
            subscribeToVideo: true
        };
        let properties = {};
        if (!!param3 && typeof param3 !== 'function') {
            properties = {
                insertMode: typeof param3.insertMode === 'string' ? VideoInsertMode_1.VideoInsertMode[param3.insertMode] : defaultProperties.insertMode,
                subscribeToAudio: typeof param3.subscribeToAudio !== 'undefined' ? param3.subscribeToAudio : defaultProperties.subscribeToAudio,
                subscribeToVideo: typeof param3.subscribeToVideo !== 'undefined' ? param3.subscribeToVideo : defaultProperties.subscribeToVideo
            };
            if (properties.subscribeToAudio === false && properties.subscribeToVideo === false) {
                throw new Error('You cannot subscribe to a stream with both audio and video disabled');
            }
        }
        else {
            properties = Object.assign({}, defaultProperties);
        }
        return properties;
    }
    connectionCreatedEventReady(participant) {
        // The local participant already received the two necessay events for this remote participant
        this.LIVEKIT_EVENT_CUSTOM_SIGNAL.delete(participant.identity);
        let connection = this.remoteConnections.get(participant.identity);
        if (connection) {
            logger.warn('Connection ' +
                participant.identity +
                ' already exists in list of remote connections for local participant ' +
                this.room.localParticipant.identity);
        }
        else {
            connection = new Connection_1.Connection(this, participant);
            this.remoteConnections.set(connection.connectionId, connection);
        }
        const connectionEvent = new ConnectionEvent_1.ConnectionEvent(false, this, 'connectionCreated', connection, '');
        this.publicEmmiter.emitEvent('connectionCreated', [connectionEvent]);
        this.publicEmmiter.emitEvent('connection-created-event-for-participant-' + connection.connectionId, []);
    }
    /**
     * Handles the ParticipantConnected event for a remote participant.
     * If the connection already exists, a warning is logged and the function returns.
     * Otherwise, a new connection is created and added to the list of remote connections.
     * Finally, a 'connectionCreated' event is emitted.
     *
     * @param participant - The remote participant for which the connection is created.
     */
    handleParticipantConnectedEvent(participant) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isIpCam(participant)) {
                this.connectionCreatedEventReady(participant);
                return;
            }
            // Send to the newly connected remote participant the local participant's custom signal
            yield this.sendCustomConnectionCreatedSignal([participant.identity]);
            // Check if the local participant has already received the two necessary events for this remote participant
            if (!this.LIVEKIT_EVENT_CUSTOM_SIGNAL.has(participant.identity)) {
                // First time local participant knows about this remote participant
                this.LIVEKIT_EVENT_CUSTOM_SIGNAL.set(participant.identity, { livekit: true, custom: false });
            }
            else {
                // Local participant already knows about this remote participant. Custom signal already received
                const events = this.LIVEKIT_EVENT_CUSTOM_SIGNAL.get(participant.identity);
                events.livekit = true;
                if (events.livekit && events.custom) {
                    this.connectionCreatedEventReady(participant);
                }
                else {
                    // This should never happen. If there is an element in the map, it means the custom signal has to be received
                    console.error('Unknown error. Custom signal not received in local participant ' +
                        this.room.localParticipant.identity +
                        ' for remote participant ' +
                        participant.identity);
                }
            }
        });
    }
    handleParticipantDisconnectedEvent(participant) {
        logger.log('Participant disconnected', participant);
        this.LIVEKIT_EVENT_CUSTOM_SIGNAL.delete(participant.identity);
        const connection = this.remoteConnections.get(participant.identity);
        if (!connection) {
            logger.warn(`Connection ${participant.identity} not found`);
            return;
        }
        this.remoteConnections.delete(connection.connectionId);
        this.participantRemoteStreams.delete(participant.identity);
        this.participantStreamsToSubscribe.delete(participant.identity);
        this.publicEmmiter.emitEvent('connectionDestroyed', [
            new ConnectionEvent_1.ConnectionEvent(false, this, 'connectionDestroyed', connection, 'disconnect')
        ]);
    }
    /**
     * Handles the recording status changed event.
     * It emits 'recordingStarted' and 'recordingStopped' events. Also emits 'connectionPropertyChanged' event with the new value of the 'record' property.
     */
    handleServerEvent(payload, participant, kind, topic) {
        // Skip event if it is not from the server
        const strData = this.decodeData(payload);
        let dataObj;
        try {
            dataObj = JSON.parse(strData);
        }
        catch (error) {
            // If the data is not a JSON, it is a string
            dataObj = strData;
        }
        if (!dataObj.sentFromServer)
            return;
        const eventInfo = dataObj.payload;
        const privateEventName = topic;
        let event;
        switch (privateEventName) {
            case `${InternalSignalTypes_1.InternalSignalType.OPENVIDU_RECORDING_STARTED}`:
                event = new RecordingEvent_1.RecordingEvent(this, 'recordingStarted', eventInfo.id, eventInfo.name);
                this.publicEmmiter.emitEvent('recordingStarted', [event]);
                break;
            case `${InternalSignalTypes_1.InternalSignalType.OPENVIDU_RECORDING_STOPPED}`:
                event = new RecordingEvent_1.RecordingEvent(this, 'recordingStopped', eventInfo.id, eventInfo.name, eventInfo.reason);
                this.publicEmmiter.emitEvent('recordingStopped', [event]);
                break;
            case `${InternalSignalTypes_1.InternalSignalType.OPENVIDU_BROADCASTING_STARTED}`:
                this.publicEmmiter.emitEvent('broadcastStarted', []);
                break;
            case `${InternalSignalTypes_1.InternalSignalType.OPENVIDU_BROADCASTING_STOPPED}`:
                this.publicEmmiter.emitEvent('broadcastStopped', []);
                break;
            case `${InternalSignalTypes_1.InternalSignalType.OPENVIDU_UNPUBLISH_STREAM}`:
                this.ongoingForceUnpublishReason = eventInfo.reason;
                this.unpublish(this.connection.stream.streamManager);
                break;
            default:
                // Regular 'signal' events sent from server
                this.emitSignalEventIfNecessary({ data: dataObj.payload || '', type: topic || '', to: [] }, undefined);
                return;
        }
    }
    /**
     * Handles the event when a track is muted or unmuted.
     * It emits a 'streamPropertyChanged' event.
     *
     * @param publication - The track publication that was muted or unmuted.
     * @param participant - The participant associated with the track publication.
     */
    handleTrackMutedUnmutedEvent(publication, participant) {
        let connection;
        if (participant.identity === this.localParticipant.identity) {
            connection = this.connection;
        }
        else {
            connection = this.remoteConnections.get(participant.identity);
            if (!connection) {
                return;
            }
        }
        const stream = connection.stream;
        if (!stream) {
            return;
        }
        const changedProperty = publication.kind === livekit_client_1.Track.Kind.Audio ? 'audioActive' : 'videoActive';
        const newValue = publication.isMuted ? false : true;
        const reason = publication.kind === livekit_client_1.Track.Kind.Audio ? 'publishAudio' : 'publishVideo';
        stream[changedProperty] = newValue;
        // Emit event from Session
        const sessionEvent = new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(this, stream, changedProperty, newValue, !newValue, reason);
        this.publicEmmiter.emitEvent('streamPropertyChanged', [sessionEvent]);
        // Emit event from StreamManager (subscriber and publisher)
        if (connection.stream.streamManager) {
            const streamManagerEvent = new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(connection.stream.streamManager, stream, changedProperty, newValue, !newValue, reason);
            connection.stream.streamManager.publicEmmiter.emitEvent('streamPropertyChanged', [streamManagerEvent]);
        }
    }
    /**
     * Handles the session disconnected event.
     *
     * @param reason The reason for the disconnection.
     */
    handleSessionDisconnectedEvent(reason) {
        this.LIVEKIT_EVENT_CUSTOM_SIGNAL.clear();
        const reasonStr = Object.keys(livekit_client_1.DisconnectReason).find((key) => livekit_client_1.DisconnectReason[key] === reason);
        logger.debug('participant disconnected', reasonStr);
        const sessionDisconnectEvent = new SessionDisconnectedEvent_1.SessionDisconnectedEvent(this, reason);
        this.publicEmmiter.emitEvent('sessionDisconnected', [sessionDisconnectEvent]);
        sessionDisconnectEvent.callDefaultBehavior();
    }
    handleTrackPublishedEvent(publication, participant) {
        var _a, _b;
        if (this.isIpCam(participant)) {
            this.handleTrackPublishedEventForIpCamera(publication, participant);
            return;
        }
        const streamId = publication.trackName;
        const { videoTrackId, videoActive, audioTrackId, audioActive } = this.getTrackIdsFromStreamId(streamId);
        let remoteStream = (_a = this.participantRemoteStreams.get(participant.identity)) === null || _a === void 0 ? void 0 : _a.get(streamId);
        if (remoteStream != null) {
            // This is not the first TrackPublished event for this stream
            if (remoteStream[publication.kind]) {
                // DUPLICATED TrackPublished event for this track!
                console.warn('DUPLICATED TrackPublished event in participant ' +
                    this.room.localParticipant.identity +
                    ' for track ' +
                    publication.trackSid +
                    ' of stream ' +
                    streamId +
                    ' of remote participant ' +
                    participant.identity);
                return;
            }
            const tr = {
                id: `${publication.kind}:${publication.source}`,
                kind: publication.kind,
                source: publication.source,
                trackPublishedEventReceived: true,
                trackUnpublishedEventReceived: false,
                trackSubscribedEventReceived: false,
                localTrackUnpublishedEventReceived: false
            };
            remoteStream[publication.kind] = tr;
        }
        else {
            // First TrackPublished event for this stream
            remoteStream = { streamId, videoId: videoTrackId, videoActive, audioId: audioTrackId, audioActive };
            const tr = {
                id: `${publication.kind}:${publication.source}`,
                kind: publication.kind,
                source: publication.source,
                trackPublishedEventReceived: true,
                trackUnpublishedEventReceived: false,
                trackSubscribedEventReceived: false,
                localTrackUnpublishedEventReceived: false
            };
            remoteStream[publication.kind] = tr;
            if (!this.participantRemoteStreams.has(participant.identity)) {
                // First stream of this participant
                const map = new Map();
                map.set(remoteStream.streamId, remoteStream);
                this.participantRemoteStreams.set(participant.identity, map);
            }
            else {
                // A different stream of this participant
                (_b = this.participantRemoteStreams.get(participant.identity)) === null || _b === void 0 ? void 0 : _b.set(remoteStream.streamId, remoteStream);
            }
        }
        let allTrackPublishedEventsReceived = true;
        // Check if video is also active for avoiding unnecessary waiting
        if (remoteStream.videoId && remoteStream.videoActive) {
            allTrackPublishedEventsReceived =
                allTrackPublishedEventsReceived && remoteStream.video != null && remoteStream.video.trackPublishedEventReceived;
        }
        if (remoteStream.audioId) {
            allTrackPublishedEventsReceived =
                allTrackPublishedEventsReceived && remoteStream.audio != null && remoteStream.audio.trackPublishedEventReceived;
        }
        if (allTrackPublishedEventsReceived) {
            logger.debug(`Local participant ${this.localParticipant.identity} received all TrackPublished events for stream ${remoteStream.streamId} of remote participant ${participant.identity}`);
            const remoteConnectionAlreadyExists = this.remoteConnections.has(participant.identity);
            let remoteConnection = new Connection_1.Connection(this, participant, remoteStream);
            this.remoteConnections.set(remoteConnection.connectionId, remoteConnection);
            remoteStream.stream = remoteConnection.stream;
            if (remoteConnectionAlreadyExists) {
                // The connectionCreated event for this remote participant has already been triggered. Immediately trigger streamCreated event
                const streamEvent = new StreamEvent_1.StreamEvent(false, this, 'streamCreated', remoteConnection.stream, '');
                this.publicEmmiter.emitEvent('streamCreated', [streamEvent]);
            }
            else {
                // Wait until connectionCreated event is triggered for this remote participant
                this.publicEmmiter.once('connection-created-event-for-participant-' + remoteConnection.connectionId, () => {
                    const streamEvent = new StreamEvent_1.StreamEvent(false, this, 'streamCreated', remoteConnection.stream, '');
                    this.publicEmmiter.emitEvent('streamCreated', [streamEvent]);
                });
            }
        }
        else {
            logger.debug(`Local participant ${this.localParticipant.identity} waiting for the remaining TrackPublished events of stream ${remoteStream.streamId} of remote participant ${participant.identity}`);
        }
    }
    handleTrackUnpublishedEvent(publication, participant) {
        const remoteStreams = this.participantRemoteStreams.get(participant.identity);
        if (!remoteStreams) {
            logger.error(`Local participant ${this.localParticipant.identity} does not have any associated tracks when handling TrackUnpublished event for remote participant ${participant.identity}`);
            return;
        }
        const remoteStream = Array.from(remoteStreams.values()).find((streamAux) => {
            var _a;
            return ((this.isIpCam(participant) || streamAux.streamId === publication.trackName) &&
                ((_a = streamAux[publication.kind]) === null || _a === void 0 ? void 0 : _a.id) === `${publication.kind}:${publication.source}`);
        });
        if (!remoteStream) {
            logger.error(`Local participant ${participant.identity} does not have associated track ${publication.trackSid} when handling TrackUnpublished event for remote participant ${participant.identity}`);
            return;
        }
        remoteStream[publication.kind].trackUnpublishedEventReceived = true;
        let allTrackUnpublishedEventsReceived = true;
        if (remoteStream[livekit_client_1.Track.Kind.Video]) {
            allTrackUnpublishedEventsReceived =
                allTrackUnpublishedEventsReceived && remoteStream[livekit_client_1.Track.Kind.Video].trackUnpublishedEventReceived;
        }
        if (remoteStream[livekit_client_1.Track.Kind.Audio]) {
            allTrackUnpublishedEventsReceived =
                allTrackUnpublishedEventsReceived && remoteStream[livekit_client_1.Track.Kind.Audio].trackUnpublishedEventReceived;
        }
        if (allTrackUnpublishedEventsReceived) {
            logger.debug(`Local participant ${this.localParticipant.identity} received all TrackUnpublished events for stream ${remoteStream.streamId} of remote participant ${participant.identity}`);
            this.participantRemoteStreams.get(participant.identity).delete(remoteStream.streamId);
            const streamEvent = new StreamEvent_1.StreamEvent(true, this, 'streamDestroyed', remoteStream.stream, 'unpublish');
            this.publicEmmiter.emitEvent('streamDestroyed', [streamEvent]);
            streamEvent.callDefaultBehavior();
        }
        else {
            logger.debug(`Local participant ${this.localParticipant.identity} waiting for the remaining TrackUnpublished events of stream ${remoteStream.streamId} of remote participant ${participant.identity}`);
        }
    }
    // For the local streamDestroyed event
    handleLocalTrackUnpublishedEvent(publication, participant) {
        const localStream = Array.from(this.participantLocalStreams.values()).find((streamAux) => {
            var _a;
            return (streamAux.streamId === publication.trackName &&
                ((_a = streamAux[publication.kind]) === null || _a === void 0 ? void 0 : _a.id) === `${publication.kind}:${publication.source}`);
        });
        if (!localStream) {
            logger.error(`Local participant ${participant.identity} does not have associated track ${publication.trackSid}`);
            return;
        }
        localStream[publication.kind].localTrackUnpublishedEventReceived = true;
        let allLocalTrackUnpublishedEventsReceived = true;
        if (localStream[livekit_client_1.Track.Kind.Video]) {
            allLocalTrackUnpublishedEventsReceived =
                allLocalTrackUnpublishedEventsReceived && localStream[livekit_client_1.Track.Kind.Video].localTrackUnpublishedEventReceived;
        }
        if (localStream[livekit_client_1.Track.Kind.Audio]) {
            allLocalTrackUnpublishedEventsReceived =
                allLocalTrackUnpublishedEventsReceived && localStream[livekit_client_1.Track.Kind.Audio].localTrackUnpublishedEventReceived;
        }
        if (allLocalTrackUnpublishedEventsReceived) {
            logger.debug(`Local participant ${this.localParticipant.identity} received all LocalTrackUnpublished events for stream ${localStream.streamId}`);
            this.participantLocalStreams.delete(localStream.streamId);
            // Set the unpublish reason if it was forced
            let reason = this.ongoingForceUnpublishReason != null ? this.ongoingForceUnpublishReason : 'unpublish';
            delete this.ongoingForceUnpublishReason;
            this.connection.stream.ee.emitEvent('local-stream-destroyed', [reason]);
        }
        else {
            logger.debug(`Local participant ${this.localParticipant.identity} waiting for the remaining LocalTrackUnpublished events of stream ${localStream.streamId}`);
        }
    }
    // To trigger the "openvidu-stream-ready-to-attach" event for remote streams
    handleTrackSubscribedEvent(track, publication, participant) {
        var _a, _b;
        if (this.isIpCam(participant)) {
            this.handleTrackSubscribedEventForIpCamera(track, publication, participant);
            return;
        }
        const streamId = publication.trackName;
        const { videoTrackId, videoActive, audioTrackId, audioActive } = this.getTrackIdsFromStreamId(streamId);
        let remoteStream = (_a = this.participantStreamsToSubscribe.get(participant.identity)) === null || _a === void 0 ? void 0 : _a.get(streamId);
        if (remoteStream != null) {
            // This is not the first TrackSubscribed event for this stream
            const tr = {
                id: `${publication.kind}:${publication.source}`,
                kind: publication.kind,
                source: publication.source,
                trackPublishedEventReceived: false,
                trackUnpublishedEventReceived: false,
                trackSubscribedEventReceived: true,
                localTrackUnpublishedEventReceived: false
            };
            remoteStream[publication.kind] = tr;
        }
        else {
            // First TrackSubscribed event for this stream
            remoteStream = { streamId, videoId: videoTrackId, videoActive, audioId: audioTrackId, audioActive };
            const tr = {
                id: `${publication.kind}:${publication.source}`,
                kind: publication.kind,
                source: publication.source,
                trackPublishedEventReceived: false,
                trackUnpublishedEventReceived: false,
                trackSubscribedEventReceived: true,
                localTrackUnpublishedEventReceived: false
            };
            remoteStream[publication.kind] = tr;
            if (!this.participantStreamsToSubscribe.has(participant.identity)) {
                // First stream of this participant
                const map = new Map();
                map.set(remoteStream.streamId, remoteStream);
                this.participantStreamsToSubscribe.set(participant.identity, map);
            }
            else {
                // A different stream of this participant
                (_b = this.participantStreamsToSubscribe.get(participant.identity)) === null || _b === void 0 ? void 0 : _b.set(remoteStream.streamId, remoteStream);
            }
        }
        const connection = this.remoteConnections.get(participant.identity);
        if (track.kind === livekit_client_1.Track.Kind.Video) {
            connection.stream.videoTrack = track;
        }
        else if (track.kind === livekit_client_1.Track.Kind.Audio) {
            connection.stream.audioTrack = track;
        }
        let allTrackSubscribedEventsReceived = true;
        // Check if video is also active for avoiding unnecessary waiting
        if (remoteStream.videoId && remoteStream.videoActive) {
            allTrackSubscribedEventsReceived =
                allTrackSubscribedEventsReceived && remoteStream.video != null && remoteStream.video.trackSubscribedEventReceived;
        }
        if (remoteStream.audioId) {
            allTrackSubscribedEventsReceived =
                allTrackSubscribedEventsReceived && remoteStream.audio != null && remoteStream.audio.trackSubscribedEventReceived;
        }
        if (allTrackSubscribedEventsReceived) {
            logger.debug(`Local participant ${this.localParticipant.identity} received all TrackSubscribed events for stream ${remoteStream.streamId} of remote participant ${participant.identity}`);
            connection.stream.streamReadyToAttach();
        }
        else {
            logger.debug(`Local participant ${this.localParticipant.identity} waiting for the remaining TrackSubscribed events of stream ${remoteStream.streamId} of remote participant ${participant.identity}`);
        }
    }
    // To reset the subscription of a Stream
    handleTrackUnsubscribedEvent(track, publication, participant) {
        const remoteStreams = this.participantStreamsToSubscribe.get(participant.identity);
        if (!remoteStreams) {
            logger.error(`Local participant ${this.localParticipant.identity} does not have any associated tracks when handling TrackUnsubscribed event for remote participant ${participant.identity}`);
            return;
        }
        const remoteStream = Array.from(remoteStreams.values()).find((streamAux) => {
            var _a;
            return (
            // First condition must be ignored for IP cameras
            (this.isIpCam(participant) || streamAux.streamId === publication.trackName) &&
                ((_a = streamAux[publication.kind]) === null || _a === void 0 ? void 0 : _a.id) === `${publication.kind}:${publication.source}`);
        });
        if (!remoteStream) {
            logger.error(`Local participant ${participant.identity} does not have associated track ${publication.trackSid} when handling TrackUnsubscribed event for remote participant ${participant.identity}`);
            return;
        }
        remoteStream[track.kind].trackSubscribedEventReceived = false;
    }
    handleNetworkQualityLevelChanged(quality, participant) {
        logger.debug('Network quality changed', quality);
        const oldValue = this.networkQualityLevelValue;
        switch (quality) {
            case livekit_client_1.ConnectionQuality.Excellent:
                this.networkQualityLevelValue = 5; // Excellent
                break;
            case livekit_client_1.ConnectionQuality.Good:
                this.networkQualityLevelValue = 3; // Non Optimal
                break;
            case livekit_client_1.ConnectionQuality.Poor:
                this.networkQualityLevelValue = 1; // Bad
                break;
            // case ConnectionQuality.Unknown:
            //     this.networkQualityLevelValue = 1;
            //     break;
            default:
                break;
        }
        // Avoid send event if the network quality level has not changed
        if (oldValue === this.networkQualityLevelValue)
            return;
        const connection = participant.identity === this.localParticipant.identity ? this.connection : this.remoteConnections.get(participant.identity);
        const event = new NetworkQualityLevelChangedEvent_1.NetworkQualityLevelChangedEvent(this, this.networkQualityLevelValue, oldValue, connection);
        this.publicEmmiter.emitEvent('networkQualityLevelChanged', [event]);
    }
    decodeData(data) {
        const decoder = new TextDecoder();
        return decoder.decode(data);
    }
    generateRoomConnectOptions() {
        const options = {
            autoSubscribe: false,
            /** specifies how often an initial join connection is allowed to retry (only applicable if server is not reachable) */
            maxRetries: 3,
            /** amount of time for PeerConnection to be established, defaults to 15s */
            peerConnectionTimeout: 15000,
            /** amount of time for Websocket connection to be established, defaults to 15s */
            websocketTimeout: 15000,
            /** autosubscribe to room tracks after joining, defaults to true */
            /**
             * use to override any RTCConfiguration options.
             */
            rtcConfig: {
            // bundlePolicy?: RTCBundlePolicy;
            // certificates?: RTCCertificate[];
            // iceCandidatePoolSize?: number;
            // iceServers: RTCIceServer[],
            // iceTransportPolicy?: RTCIceTransportPolicy;
            // rtcpMuxPolicy?: RTCRtcpMuxPolicy;
            }
        };
        if (this.openvidu.advancedConfiguration.iceServers) {
            let iceServers;
            if (typeof this.openvidu.advancedConfiguration.iceServers === 'string') {
                // Convert the string to RTCIceServer[] here
                // This is just a placeholder. You'll need to replace this with actual logic
                iceServers = [{ urls: this.openvidu.advancedConfiguration.iceServers }];
            }
            else {
                iceServers = this.openvidu.advancedConfiguration.iceServers;
            }
            options.rtcConfig = {
                iceServers: iceServers
            };
        }
        return options;
    }
    /**
     * @hidden
     */
    notConnectedError() {
        return new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.OPENVIDU_NOT_CONNECTED, "There is no connection to the session. Method 'Session.connect' must be successfully completed first");
    }
    /**
     * @hidden
     */
    anySpeechEventListenerEnabled(event, onlyOnce) {
        let handlersInSession = this.publicEmmiter.getListeners(event);
        if (onlyOnce) {
            handlersInSession = handlersInSession.filter((h) => h.once);
        }
        let listenersInSession = handlersInSession.length;
        return listenersInSession > 0;
    }
    processClientMetadata(participantMetadata) {
        if (!participantMetadata)
            return undefined;
        const existingMetadata = this.room.localParticipant.metadata;
        let clientData = participantMetadata;
        if (typeof participantMetadata === 'object') {
            clientData = JSON.stringify(participantMetadata);
        }
        let updatedMetadata = clientData;
        try {
            if (existingMetadata) {
                const parsedMetadata = JSON.parse(existingMetadata);
                if (parsedMetadata && typeof parsedMetadata === 'object') {
                    const mergedMetadata = Object.assign(Object.assign({}, parsedMetadata), { clientData });
                    updatedMetadata = JSON.stringify(mergedMetadata);
                }
            }
            return updatedMetadata;
        }
        catch (error) {
            logger.error('Error updating client data in the local participant metadata:');
            return existingMetadata;
        }
    }
    /**
     * A streamId has format 'str__PARTICIPANTID__RANDOMSTRING__V__VIDEOTRACKKIND-VIDEOTRACKSOURCE__A__AUDIOTRACKKIND-AUDIOTRACKSOURCE'
     * For example:
     * A stream with webcam and microphone: str__con_wgl95olcmg__a0ctoii7__V__video-camera__A__audio-microphone
     * A stream with only webcam: str__con_jrdkllbejo__6ku5svc6__V__video-camera__A__
     * A stream with only microphone: str__con_8qkkiavfq8__rexvee7l__V____A__audio-microphone
     * A stream with screen share and screen audio: str__con_c0v9gy5iog__vhfvbh1l__V__video-screen_share__A__audio-screen_share_audio
     * @returns [videoTrackId, audioTrackId] being undefined if the track is not present, and TRACKKIND-TRACKSOURCE as track id if present
     */
    getTrackIdsFromStreamId(streamId) {
        const videoMatch = streamId.match(/__V__(.*?)(-muted)?__A__/);
        const audioMatch = streamId.match(/__A__(.*?)(-muted)?$/);
        const videoTrackId = videoMatch === null || videoMatch === void 0 ? void 0 : videoMatch[1];
        const audioTrackId = audioMatch === null || audioMatch === void 0 ? void 0 : audioMatch[1];
        const videoActive = !(videoMatch === null || videoMatch === void 0 ? void 0 : videoMatch[2]); // If '-muted' is present, videoActive is false
        const audioActive = !(audioMatch === null || audioMatch === void 0 ? void 0 : audioMatch[2]); // If '-muted' is present, audioActive is false
        return {
            videoTrackId: videoTrackId || undefined,
            audioTrackId: audioTrackId || undefined,
            videoActive,
            audioActive
        };
    }
    handleTrackPublishedEventForIpCamera(publication, participant) {
        var _a, _b;
        let streamId = `str__${participant.identity}`;
        let videoTrackId, videoActive, audioTrackId, audioActive;
        if (publication.kind === livekit_client_1.Track.Kind.Video) {
            videoTrackId = publication.trackSid;
            videoActive = true;
        }
        else {
            audioTrackId = publication.trackSid;
            audioActive = true;
        }
        let remoteStream = (_a = this.participantRemoteStreams.get(participant.identity)) === null || _a === void 0 ? void 0 : _a.get(streamId);
        const allIpCameraTracksHaveBeenPublished = (remStream, calledByTimeout) => {
            logger.debug(`Local participant ${this.localParticipant.identity} received all TrackPublished events for stream ${remStream.streamId} of remote participant ${participant.identity}`);
            if (calledByTimeout) {
                logger.warn(`Triggering streamCreated after ${this.IP_CAMERAS_STREAM_CREATED_TIMEOUT}ms timeout for IP camera`);
            }
            let remoteConnection = new Connection_1.Connection(this, participant, remStream);
            remoteConnection.stream.streamId = remStream.streamId;
            this.remoteConnections.set(remoteConnection.connectionId, remoteConnection);
            remStream.stream = remoteConnection.stream;
            const streamEvent = new StreamEvent_1.StreamEvent(false, this, 'streamCreated', remoteConnection.stream, '');
            this.publicEmmiter.emitEvent('streamCreated', [streamEvent]);
        };
        if (remoteStream != null) {
            // This is not the first TrackPublished event for this stream
            if (remoteStream[publication.kind]) {
                // DUPLICATED TrackPublished event for this track!
                console.warn('DUPLICATED TrackPublished event in participant ' +
                    this.room.localParticipant.identity +
                    ' for track ' +
                    publication.trackSid +
                    ' of stream ' +
                    streamId +
                    ' of remote participant ' +
                    participant.identity);
                return;
            }
            const tr = {
                id: `${publication.kind}:${publication.source}`,
                kind: publication.kind,
                source: publication.source,
                trackPublishedEventReceived: true,
                trackUnpublishedEventReceived: false,
                trackSubscribedEventReceived: false,
                localTrackUnpublishedEventReceived: false
            };
            remoteStream[publication.kind] = tr;
            const ipCameraTimeout = this.ipCamerasTimeouts.get(participant.identity);
            clearTimeout(ipCameraTimeout);
            this.ipCamerasTimeouts.delete(participant.identity);
            allIpCameraTracksHaveBeenPublished(remoteStream, false);
        }
        else {
            // First TrackPublished event for this stream
            remoteStream = { streamId, videoId: videoTrackId, videoActive, audioId: audioTrackId, audioActive };
            const tr = {
                id: `${publication.kind}:${publication.source}`,
                kind: publication.kind,
                source: publication.source,
                trackPublishedEventReceived: true,
                trackUnpublishedEventReceived: false,
                trackSubscribedEventReceived: false,
                localTrackUnpublishedEventReceived: false
            };
            remoteStream[publication.kind] = tr;
            if (!this.participantRemoteStreams.has(participant.identity)) {
                // First stream of this participant
                const map = new Map();
                map.set(remoteStream.streamId, remoteStream);
                this.participantRemoteStreams.set(participant.identity, map);
            }
            else {
                // A different stream of this participant
                (_b = this.participantRemoteStreams.get(participant.identity)) === null || _b === void 0 ? void 0 : _b.set(remoteStream.streamId, remoteStream);
            }
            this.ipCamerasTimeouts.set(participant.identity, setTimeout(() => allIpCameraTracksHaveBeenPublished(remoteStream, true), this.IP_CAMERAS_STREAM_CREATED_TIMEOUT));
        }
    }
    handleTrackSubscribedEventForIpCamera(track, publication, participant) {
        var _a, _b;
        let streamId = `str__${participant.identity}`;
        let videoTrackId = publication.trackSid;
        let videoActive = true;
        let audioTrackId = publication.trackSid;
        let audioActive = true;
        let remoteStream = (_a = this.participantStreamsToSubscribe.get(participant.identity)) === null || _a === void 0 ? void 0 : _a.get(streamId);
        if (remoteStream != null) {
            // This is not the first TrackSubscribed event for this stream
            const tr = {
                id: `${publication.kind}:${publication.source}`,
                kind: publication.kind,
                source: publication.source,
                trackPublishedEventReceived: false,
                trackUnpublishedEventReceived: false,
                trackSubscribedEventReceived: true,
                localTrackUnpublishedEventReceived: false
            };
            remoteStream[publication.kind] = tr;
        }
        else {
            // First TrackSubscribed event for this stream
            remoteStream = { streamId, videoId: videoTrackId, videoActive, audioId: audioTrackId, audioActive };
            const tr = {
                id: `${publication.kind}:${publication.source}`,
                kind: publication.kind,
                source: publication.source,
                trackPublishedEventReceived: false,
                trackUnpublishedEventReceived: false,
                trackSubscribedEventReceived: true,
                localTrackUnpublishedEventReceived: false
            };
            remoteStream[publication.kind] = tr;
            if (!this.participantStreamsToSubscribe.has(participant.identity)) {
                // First stream of this participant
                const map = new Map();
                map.set(remoteStream.streamId, remoteStream);
                this.participantStreamsToSubscribe.set(participant.identity, map);
            }
            else {
                // A different stream of this participant
                (_b = this.participantStreamsToSubscribe.get(participant.identity)) === null || _b === void 0 ? void 0 : _b.set(remoteStream.streamId, remoteStream);
            }
        }
        const connection = this.remoteConnections.get(participant.identity);
        if (track.kind === livekit_client_1.Track.Kind.Video) {
            connection.stream.videoTrack = track;
        }
        else if (track.kind === livekit_client_1.Track.Kind.Audio) {
            connection.stream.audioTrack = track;
        }
        let allTrackSubscribedEventsReceived = true;
        // Check if video is also active for avoiding unnecessary waiting
        if (remoteStream.videoId && remoteStream.videoActive) {
            allTrackSubscribedEventsReceived =
                allTrackSubscribedEventsReceived && remoteStream.video != null && remoteStream.video.trackSubscribedEventReceived;
        }
        if (remoteStream.audioId) {
            allTrackSubscribedEventsReceived =
                allTrackSubscribedEventsReceived && remoteStream.audio != null && remoteStream.audio.trackSubscribedEventReceived;
        }
        if (allTrackSubscribedEventsReceived) {
            logger.debug(`Local participant ${this.localParticipant.identity} received all TrackSubscribed events for stream ${remoteStream.streamId} of remote participant ${participant.identity}`);
            connection.stream.streamReadyToAttach();
        }
        else {
            logger.debug(`Local participant ${this.localParticipant.identity} waiting for the remaining TrackSubscribed events of stream ${remoteStream.streamId} of remote participant ${participant.identity}`);
        }
    }
    isIpCam(participant) {
        return participant.identity.startsWith('ipc_');
    }
}
exports.Session = Session;
//# sourceMappingURL=Session.js.map