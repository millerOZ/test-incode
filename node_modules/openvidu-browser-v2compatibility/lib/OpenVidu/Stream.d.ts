/// <reference types="node" />
import { TypeOfVideo } from '../OpenViduInternal/Enums/TypeOfVideo';
import { InboundStreamOptions } from '../OpenViduInternal/Interfaces/Private/InboundStreamOptions';
import { OutboundStreamOptions } from '../OpenViduInternal/Interfaces/Private/OutboundStreamOptions';
import { Connection } from './Connection';
import { Filter } from './Filter';
import { Session } from './Session';
import { StreamManager } from './StreamManager';
import { WebRtcPeer } from '../OpenViduInternal/WebRtcPeer/WebRtcPeer';
import { InternalSignalType } from '../OpenViduInternal/Interfaces/Private/InternalSignalTypes';
import { AudioCaptureOptions, LocalAudioTrack, LocalVideoTrack, RemoteAudioTrack, RemoteVideoTrack, ScreenShareCaptureOptions, Track, TrackPublishOptions, VideoCaptureOptions } from 'livekit-client';
import { Subject } from 'rxjs';
import EventEmitter = require('wolfy87-eventemitter');
/**
 * Represents each one of the media streams available in OpenVidu Server for certain session.
 * Each {@link Publisher} and {@link Subscriber} has an attribute of type Stream, as they give access
 * to one of them (sending and receiving it, respectively)
 */
export declare class Stream {
    /**
     * The Connection object that is publishing the stream
     */
    connection: Connection;
    /**
     * Frame rate of the video in frames per second. This property is only defined if the {@link Publisher} of
     * the stream was initialized passing a _frameRate_ property on {@link OpenVidu.initPublisher} method
     */
    frameRate?: number;
    /**
     * Whether the stream has a video track or not
     */
    hasVideo: boolean;
    /**
     * Whether the stream has an audio track or not
     */
    hasAudio: boolean;
    /**
     * Whether the stream has the video track muted or unmuted. If {@link hasVideo} is false, this property is undefined.
     *
     * This property may change if the Publisher publishing the stream calls {@link Publisher.publishVideo}. Whenever this happens a {@link StreamPropertyChangedEvent} will be dispatched
     * by the Session object as well as by the affected Subscriber/Publisher object
     */
    videoActive: boolean;
    /**
     * Whether the stream has the audio track muted or unmuted. If {@link hasAudio} is false, this property is undefined
     *
     * This property may change if the Publisher publishing the stream calls {@link Publisher.publishAudio}. Whenever this happens a {@link StreamPropertyChangedEvent} will be dispatched
     * by the Session object as well as by the affected Subscriber/Publisher object
     */
    audioActive: boolean;
    /**
     * Unique identifier of the stream. If the stream belongs to a...
     * - Subscriber object: property `streamId` is always defined
     * - Publisher object: property `streamId` is only defined after successful execution of {@link Session.publish}
     */
    streamId: string;
    /**
     * Time when this stream was created in OpenVidu Server (UTC milliseconds). Depending on the owner of this stream:
     * - Subscriber object: property `creationTime` is always defined
     * - Publisher object: property `creationTime` is only defined after successful execution of {@link Session.publish}
     */
    creationTime: number;
    /**
     * Can be:
     * - `"CAMERA"`: when the video source comes from a webcam.
     * - `"SCREEN"`: when the video source comes from screen-sharing.
     * - `"CUSTOM"`: when {@link PublisherProperties.videoSource} has been initialized in the Publisher side with a custom MediaStreamTrack when calling {@link OpenVidu.initPublisher}).
     * - `"IPCAM"`: when the video source comes from an IP camera participant instead of a regular participant (see [IP cameras](/en/stable/advanced-features/ip-cameras/)).
     *
     * If {@link hasVideo} is false, this property is undefined
     */
    typeOfVideo?: keyof typeof TypeOfVideo;
    /**
     * Width and height in pixels of the encoded video stream. If {@link hasVideo} is false, this property is undefined
     *
     * This property may change if the Publisher that is publishing:
     * - If it is a mobile device, whenever the user rotates the device.
     * - If it is screen-sharing, whenever the user changes the size of the captured window.
     *
     * Whenever this happens a {@link StreamPropertyChangedEvent} will be dispatched by the Session object as well as by the affected Subscriber/Publisher object
     */
    videoDimensions: {
        width: number;
        height: number;
    };
    /**
     * StreamManager object ({@link Publisher} or {@link Subscriber}) in charge of displaying this stream in the DOM
     */
    streamManager: StreamManager;
    /**
     * @hidden
     */
    session: Session;
    /**
     * @hidden
     */
    inboundStreamOpts: InboundStreamOptions;
    /**
     * @hidden
     */
    outboundStreamOpts: OutboundStreamOptions;
    /**
     * @hidden
     */
    internalEmitter: {
        [key in InternalSignalType]?: Subject<any>;
    };
    /**
     * @hidden
     */
    isLocalStreamReadyToPublish: boolean;
    /**
     * @hidden
     */
    isReadyToAttach: boolean;
    /**
     * @hidden
     */
    ee: EventEmitter;
    /**
     * ! Not supported in adapter
     * **WARNING**: experimental option. This interface may change in the near future
     *
     * Filter applied to the Stream. You can apply filters by calling {@link Stream.applyFilter}, execute methods of the applied filter with
     * {@link Filter.execMethod} and remove it with {@link Stream.removeFilter}. Be aware that the client calling this methods must have the
     * necessary permissions: the token owned by the client must have been initialized with the appropriated `allowedFilters` array.
     */
    filter?: Filter;
    /**
     * @hidden
     * Stores the livekit video track to be published
     */
    videoTrack: LocalVideoTrack | RemoteVideoTrack | undefined;
    /**
     * @hidden
     * Stores the livekit audio track to be published
     */
    audioTrack: LocalAudioTrack | RemoteAudioTrack | undefined;
    /**
     * @hidden
     */
    videoOptions: VideoCaptureOptions | boolean | undefined;
    /**
     * @hidden
     */
    audioOptions: AudioCaptureOptions | boolean | undefined;
    /**
     * @hidden
     */
    screenShareOptions: ScreenShareCaptureOptions | undefined;
    /**
     * @hidden
     */
    videoPublishOptions: TrackPublishOptions | undefined;
    /**
     * @hidden
     */
    audioPublishOptions: TrackPublishOptions | undefined;
    /**
     * @hidden
     */
    screenShareResizeInterval: NodeJS.Timeout | undefined;
    /**
     * @hidden
     */
    speechEvent: any;
    /**
     * @hidden
     */
    harkSpeakingEnabled: boolean;
    /**
     * @hidden
     */
    harkSpeakingEnabledOnce: boolean;
    /**
     * @hidden
     */
    harkStoppedSpeakingEnabled: boolean;
    /**
     * @hidden
     */
    harkStoppedSpeakingEnabledOnce: boolean;
    /**
     * @hidden
     */
    harkVolumeChangeEnabled: boolean;
    /**
     * @hidden
     */
    harkVolumeChangeEnabledOnce: boolean;
    /**
     * @hidden
     */
    harkOptions: any;
    /**
     * @hidden
     */
    constructor(session: Session, options: InboundStreamOptions | OutboundStreamOptions | {});
    /**
     * Returns the internal MediaStream object associated to this stream (https://developer.mozilla.org/en-US/docs/Web/API/MediaStream)
     * @returns Native MediaStream Web API object
     */
    getMediaStream(): MediaStream;
    /**
     * Returns the internal RTCPeerConnection object associated to this stream (https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection)
     *
     * @returns Native RTCPeerConnection Web API object
     */
    getRTCPeerConnection(): RTCPeerConnection;
    /**
     * @hidden
     */
    disposeWebRtcPeer(): void;
    /**
     * @hidden
     */
    disposeMediaStream(): Promise<void>;
    /**
     * @hidden
     */
    publish(): Promise<void>;
    /**
     * @hidden
     */
    streamReadyToPublish(): void;
    /**
     * @hidden
     */
    streamReadyToAttach(): void;
    /**
     * @hidden
     */
    streamJustDestroyed(): void;
    /**
     * @hidden
     */
    disableAllHarkEvents(): void;
    /**
     * @hidden
     */
    isLocal(): boolean;
    /**
     * @hidden
     */
    isSendingAudio(): boolean;
    /**
     * @hidden
     */
    isSendingVideo(): boolean;
    /**
     * @hidden
     */
    isSendingScreen(): boolean;
    /**
     * @hidden
     */
    getVideoDimensions(): Promise<Track.Dimensions>;
    /**
     * ! Not implemented yet
     * Recreates the media connection with the server. This entails the disposal of the previous RTCPeerConnection and the re-negotiation
     * of a new one, that will apply the same properties.
     *
     * This method can be useful in those situations were there the media connection breaks and OpenVidu is not able to recover on its own
     * for any kind of unanticipated reason (see [Automatic reconnection](/en/stable/advanced-features/automatic-reconnection/)).
     *
     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the reconnection operation was successful and rejected with an Error object if not
     */
    reconnect(): Promise<void>;
    /**
     * Applies an audio/video filter to the stream.
     *
     * @param type Type of filter applied. See {@link Filter.type}
     * @param options Parameters used to initialize the filter. See {@link Filter.options}
     *
     * @returns A Promise (to which you can optionally subscribe to) that is resolved to the applied filter if success and rejected with an Error object if not
     */
    applyFilter(type: string, options: Object): Promise<Filter>;
    /**
     * Removes an audio/video filter previously applied.
     *
     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the previously applied filter has been successfully removed and rejected with an Error object in other case
     */
    removeFilter(): Promise<void>;
    /**
     * ! Not supported in adapter. Test app uses it
     * @hidden
     */
    getSelectedIceCandidate(): Promise<any>;
    /**
     * ! Not supported in adapter. Test app uses it
     * @hidden
     */
    getLocalIceCandidateList(): RTCIceCandidate[];
    /**
     * ! Not supported in adapter. Test app uses it
     * @hidden
     */
    getRemoteIceCandidateList(): RTCIceCandidate[];
    /**
     * ! Not supported in adapter. Test app uses it
     *
     * @hidden
     */
    getWebRtcPeer(): WebRtcPeer;
    private handleInboundStreamOptions;
    private handleOutboundStreamOptions;
    /**
     * @hidden
     */
    enableHarkSpeakingEvent(): void;
    /**
     * @hidden
     */
    enableOnceHarkSpeakingEvent(): void;
    /**
     * @hidden
     */
    disableHarkSpeakingEvent(disabledByOnce: boolean): void;
    /**
     * @hidden
     */
    enableHarkStoppedSpeakingEvent(): void;
    /**
     * @hidden
     */
    enableOnceHarkStoppedSpeakingEvent(): void;
    /**
     * @hidden
     */
    disableHarkStoppedSpeakingEvent(disabledByOnce: boolean): void;
    /**
     * @hidden
     */
    enableHarkVolumeChangeEvent(force: boolean): void;
    /**
     * @hidden
     */
    enableOnceHarkVolumeChangeEvent(force: boolean): void;
    /**
     * @hidden
     */
    disableHarkVolumeChangeEvent(disabledByOnce: boolean): void;
    /**
     * @hidden
     */
    initHarkEvents(): void;
    private setHarkListenerIfNotExists;
}
