import { LocalParticipant, Room, Track } from 'livekit-client';
import { Connection } from './Connection';
import { EventDispatcher } from './EventDispatcher';
import { Capabilities } from '../OpenViduInternal/Interfaces/Public/Capabilities';
import { OpenVidu } from './OpenVidu';
import { Stream } from './Stream';
import { Subscriber } from './Subscriber';
import { SubscriberProperties } from '../OpenViduInternal/Interfaces/Public/SubscriberProperties';
import { Publisher } from './Publisher';
import { SignalOptions } from '../OpenViduInternal/Interfaces/Public/SignalOptions';
import { OpenViduError } from '../OpenViduInternal/Enums/OpenViduError';
import { SessionEventMap } from '../OpenViduInternal/Events/EventMap/SessionEventMap';
import { StreamManager } from './StreamManager';
/**
 * @hidden
 * type cannot be empty. Must be 'signal' or 'signal:TYPE'
 */
type SignalMessage = {
    data: string;
    type: string;
    to: string[];
};
/**
 * @hidden
 */
type StreamTrackAux = {
    id: string;
    kind: Track.Kind;
    source: string;
    trackPublishedEventReceived: boolean;
    trackUnpublishedEventReceived: boolean;
    trackSubscribedEventReceived: boolean;
    localTrackUnpublishedEventReceived: boolean;
};
/**
 * @hidden
 */
export type StreamAux = {
    streamId: string;
    videoId?: string;
    videoActive: boolean;
    audioId?: string;
    audioActive: boolean;
    [Track.Kind.Video]?: StreamTrackAux;
    [Track.Kind.Audio]?: StreamTrackAux;
    stream?: Stream;
};
/**
 * Livekit Room
 */
export declare class Session extends EventDispatcher {
    /**
     * @hidden
     */
    room: Room;
    /**
     * @hidden
     */
    openvidu: OpenVidu;
    /**
     * Unique identifier of the Session
     */
    get sessionId(): string;
    /**
     * Local connection to the Session. This object is defined only after {@link Session.connect} has been successfully executed, and can be retrieved subscribing to `connectionCreated` event
     */
    connection: Connection;
    /**
     * Collection of all StreamManagers of this Session ({@link Publisher} and {@link Subscriber})
     */
    streamManagers: StreamManager[];
    /**
     * Map of remote connections in the session.
     * Key is the remote connection identifier
     */
    remoteConnections: Map<string, Connection>;
    private isRecorderParticipant;
    get capabilities(): Capabilities;
    /**
     * @hidden
     */
    get localParticipant(): LocalParticipant;
    private token;
    private networkQualityLevelValue;
    private participantLocalStreams;
    private participantRemoteStreams;
    private participantStreamsToSubscribe;
    private IP_CAMERAS_STREAM_CREATED_TIMEOUT;
    private ipCamerasTimeouts;
    private ongoingForceUnpublishReason;
    private ws;
    private LIVEKIT_EVENT_CUSTOM_SIGNAL;
    constructor(openvidu: OpenVidu);
    connect(token: string): Promise<any>;
    connect(token: string, metadata: any): Promise<any>;
    /**
     * Leaves the session, destroying all streams and deleting the user as a participant.
     *
     * #### Events dispatched
     *
     * The {@link Session} object of the local participant will dispatch a `sessionDisconnected` event.
     * This event will automatically unsubscribe the leaving participant from every Subscriber object of the session (this includes closing the RTCPeerConnection and disposing all MediaStreamTracks)
     * and also deletes any HTML video element associated to each Subscriber (only those [created by OpenVidu Browser](/en/stable/cheatsheet/manage-videos/#let-openvidu-take-care-of-the-video-players)).
     * For every video removed, each Subscriber object will dispatch a `videoElementDestroyed` event.
     * Call `event.preventDefault()` upon event `sessionDisconnected` to avoid this behavior and take care of disposing and cleaning all the Subscriber objects yourself.
     * See {@link SessionDisconnectedEvent} and {@link VideoElementEvent} to learn more.
     *
     * The {@link Publisher} object of the local participant will dispatch a `streamDestroyed` event if there is a {@link Publisher} object publishing to the session.
     * This event will automatically stop all media tracks and delete any HTML video element associated to it (only those [created by OpenVidu Browser](/en/stable/cheatsheet/manage-videos/#let-openvidu-take-care-of-the-video-players)).
     * For every video removed, the Publisher object will dispatch a `videoElementDestroyed` event.
     * Call `event.preventDefault()` upon event `streamDestroyed` if you want to clean the Publisher object on your own or re-publish it in a different Session (to do so it is a mandatory requirement to call `Session.unpublish()`
     * or/and `Session.disconnect()` in the previous session). See {@link StreamEvent} and {@link VideoElementEvent} to learn more.
     *
     * The {@link Session} object of every other participant connected to the session will dispatch a `streamDestroyed` event if the disconnected participant was publishing.
     * This event will automatically unsubscribe the Subscriber object from the session (this includes closing the RTCPeerConnection and disposing all MediaStreamTracks)
     * and also deletes any HTML video element associated to that Subscriber (only those [created by OpenVidu Browser](/en/stable/cheatsheet/manage-videos/#let-openvidu-take-care-of-the-video-players)).
     * For every video removed, the Subscriber object will dispatch a `videoElementDestroyed` event.
     * Call `event.preventDefault()` upon event `streamDestroyed` to avoid this default behavior and take care of disposing and cleaning the Subscriber object yourself.
     * See {@link StreamEvent} and {@link VideoElementEvent} to learn more.
     *
     * The {@link Session} object of every other participant connected to the session will dispatch a `connectionDestroyed` event in any case. See {@link ConnectionEvent} to learn more.
     */
    disconnect(): void;
    /**
     * @hidden
     */
    isSessionConnected(): boolean;
    subscribe(stream: Stream, targetElement: string | HTMLElement | undefined): Subscriber;
    subscribe(stream: Stream, targetElement: string | HTMLElement | undefined, properties: SubscriberProperties): Subscriber;
    subscribe(stream: Stream, targetElement: string | HTMLElement | undefined, completionHandler: (error: Error | undefined) => void): Subscriber;
    subscribe(stream: Stream, targetElement: string | HTMLElement | undefined, properties: SubscriberProperties, completionHandler: (error: Error | undefined) => void): Subscriber;
    /**
     * Promisified version of {@link Session.subscribe}
     */
    subscribeAsync(stream: Stream, targetElement: string | HTMLElement): Promise<Subscriber>;
    subscribeAsync(stream: Stream, targetElement: string | HTMLElement, properties: SubscriberProperties): Promise<Subscriber>;
    /**
     * Unsubscribes from `subscriber`, automatically removing its associated HTML video elements.
     *
     * #### Events dispatched
     *
     * The {@link Subscriber} object will dispatch a `videoElementDestroyed` event for each video associated to it that was removed from DOM.
     * Only videos [created by OpenVidu Browser](/en/stable/cheatsheet/manage-videos/#let-openvidu-take-care-of-the-video-players)) will be automatically removed
     *
     * See {@link VideoElementEvent} to learn more
     */
    unsubscribe(subscriber: Subscriber): Promise<void>;
    /**
     * Publishes to the Session the Publisher object
     *
     * #### Events dispatched
     *
     * The local {@link Publisher} object will dispatch a `streamCreated` event upon successful termination of this method. See {@link StreamEvent} to learn more.
     *
     * The local {@link Publisher} object will dispatch a `streamPlaying` once the media stream starts playing. See {@link StreamManagerEvent} to learn more.
     *
     * The {@link Session} object of every other participant connected to the session will dispatch a `streamCreated` event so they can subscribe to it. See {@link StreamEvent} to learn more.
     *
     * @returns A Promise (to which you can optionally subscribe to) that is resolved only after the publisher was successfully published and rejected with an Error object if not
     */
    publish(publisher: Publisher): Promise<void>;
    /**
     * Unpublishes from the Session the Publisher object.
     *
     * #### Events dispatched
     *
     * The {@link Publisher} object of the local participant will dispatch a `streamDestroyed` event.
     * This event will automatically stop all media tracks and delete any HTML video element associated to this Publisher
     * (only those videos [created by OpenVidu Browser](/en/stable/cheatsheet/manage-videos/#let-openvidu-take-care-of-the-video-players)).
     * For every video removed, the Publisher object will dispatch a `videoElementDestroyed` event.
     * Call `event.preventDefault()` upon event `streamDestroyed` if you want to clean the Publisher object on your own or re-publish it in a different Session.
     *
     * The {@link Session} object of every other participant connected to the session will dispatch a `streamDestroyed` event.
     * This event will automatically unsubscribe the Subscriber object from the session (this includes closing the RTCPeerConnection and disposing all MediaStreamTracks) and
     * delete any HTML video element associated to it (only those [created by OpenVidu Browser](/en/stable/cheatsheet/manage-videos/#let-openvidu-take-care-of-the-video-players)).
     * For every video removed, the Subscriber object will dispatch a `videoElementDestroyed` event.
     * Call `event.preventDefault()` upon event `streamDestroyed` to avoid this default behavior and take care of disposing and cleaning the Subscriber object on your own.
     *
     * See {@link StreamEvent} and {@link VideoElementEvent} to learn more.
     */
    unpublish(publisher: Publisher): Promise<void>;
    forceDisconnect(connection: Connection): Promise<void>;
    forceUnpublish(stream: Stream): Promise<void>;
    /**
     * @hidden
     */
    parseSignalMessage(signal: SignalOptions): SignalMessage;
    /**
     * Sends one signal. `signal` object has the following optional properties:
     * ```json
     * {data:string, to:Connection[], type:string}
     * ```
     * All users subscribed to that signal (`session.on('signal:type', ...)` or `session.on('signal', ...)` for all signals) and whose Connection objects are in `to` array will receive it. Their local
     * Session objects will dispatch a `signal` or `signal:type` event. See {@link SignalEvent} to learn more.
     *
     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the message successfully reached openvidu-server and rejected with an Error object if not. _This doesn't
     * mean that openvidu-server could resend the message to all the listed receivers._
     */
    signal(signal: SignalOptions): Promise<void>;
    /**
     * @hidden
     */
    signalInternal(signal: SignalOptions, sendWebsocket: boolean): Promise<void>;
    private emitSignalEventIfNecessary;
    /**
     * See {@link EventDispatcher.on}
     */
    on<K extends keyof SessionEventMap>(type: K, handler: (event: SessionEventMap[K]) => void): this;
    /**
     * See {@link EventDispatcher.once}
     */
    once<K extends keyof SessionEventMap>(type: K, handler: (event: SessionEventMap[K]) => void): this;
    /**
     * See {@link EventDispatcher.off}
     */
    off<K extends keyof SessionEventMap>(type: K, handler?: (event: SessionEventMap[K]) => void): this;
    /**
     * ! Not supported in adapter
     * Subscribe to the Speech-To-Text events for this {@link Stream}. The Session object will emit {@link SpeechToTextEvent} for the Stream
     * when speech is detected in its audio track.
     *
     * @param stream - The Stream for which you want to start receiving {@link SpeechToTextEvent}.
     * @param lang - The language of the Stream's audio track. It must be a valid [BCP-47](https://tools.ietf.org/html/bcp47) language tag like "en-US" or "es-ES".
     *
     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the speech-to-text subscription
     * was successful and rejected with an Error object if not.
     */
    subscribeToSpeechToText(stream: Stream, lang: string): Promise<void>;
    /**
     * ! Not supported in adapter
     * Unsubscribe from the Speech-To-Text events for this {@link Stream}.
     *
     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the speech-to-text subscription
     * was successful and rejected with an Error object if not.
     */
    unsubscribeFromSpeechToText(stream: Stream): Promise<void>;
    private extractInfoFromOpenViduToken;
    private handleMediaDevicesErrorEvent;
    /**
     * Sends a custom connection created event to remote connections.
     * This custom event is used to notify other participants that a new connection has been created after local participant
     * metadata has been updated.
     *
     * @remarks
     * This method sends a custom connection created event to the server.
     *
     * @returns A promise that resolves when the event is sent successfully.
     */
    private sendCustomConnectionCreatedSignal;
    private handleRoomConnectedEvent;
    private handleParticipantMetadataChangedEvent;
    /**
     * Processes the session connected event.
     * Initializes remote connections and emits corresponding events.
     */
    private processSessionConnected;
    /**
     * Handles the room data received event.
     * It is also used for receiving internal events from other participants.
     * If the event is a signal event, it is emitted to the public emmiter.
     *
     * @param payload - The payload data received.
     * @param participant - The participant associated with the event.
     * @param kind - The kind of data packet.
     * @param topic - The topic of the event.
     */
    private handleClientEvent;
    private processAndGetSubscriberProperties;
    private connectionCreatedEventReady;
    /**
     * Handles the ParticipantConnected event for a remote participant.
     * If the connection already exists, a warning is logged and the function returns.
     * Otherwise, a new connection is created and added to the list of remote connections.
     * Finally, a 'connectionCreated' event is emitted.
     *
     * @param participant - The remote participant for which the connection is created.
     */
    private handleParticipantConnectedEvent;
    private handleParticipantDisconnectedEvent;
    /**
     * Handles the recording status changed event.
     * It emits 'recordingStarted' and 'recordingStopped' events. Also emits 'connectionPropertyChanged' event with the new value of the 'record' property.
     */
    private handleServerEvent;
    /**
     * Handles the event when a track is muted or unmuted.
     * It emits a 'streamPropertyChanged' event.
     *
     * @param publication - The track publication that was muted or unmuted.
     * @param participant - The participant associated with the track publication.
     */
    private handleTrackMutedUnmutedEvent;
    /**
     * Handles the session disconnected event.
     *
     * @param reason The reason for the disconnection.
     */
    private handleSessionDisconnectedEvent;
    private handleTrackPublishedEvent;
    private handleTrackUnpublishedEvent;
    private handleLocalTrackUnpublishedEvent;
    private handleTrackSubscribedEvent;
    private handleTrackUnsubscribedEvent;
    private handleNetworkQualityLevelChanged;
    private decodeData;
    private generateRoomConnectOptions;
    /**
     * @hidden
     */
    notConnectedError(): OpenViduError;
    /**
     * @hidden
     */
    anySpeechEventListenerEnabled(event: string, onlyOnce: boolean): boolean;
    private processClientMetadata;
    /**
     * A streamId has format 'str__PARTICIPANTID__RANDOMSTRING__V__VIDEOTRACKKIND-VIDEOTRACKSOURCE__A__AUDIOTRACKKIND-AUDIOTRACKSOURCE'
     * For example:
     * A stream with webcam and microphone: str__con_wgl95olcmg__a0ctoii7__V__video-camera__A__audio-microphone
     * A stream with only webcam: str__con_jrdkllbejo__6ku5svc6__V__video-camera__A__
     * A stream with only microphone: str__con_8qkkiavfq8__rexvee7l__V____A__audio-microphone
     * A stream with screen share and screen audio: str__con_c0v9gy5iog__vhfvbh1l__V__video-screen_share__A__audio-screen_share_audio
     * @returns [videoTrackId, audioTrackId] being undefined if the track is not present, and TRACKKIND-TRACKSOURCE as track id if present
     */
    private getTrackIdsFromStreamId;
    private handleTrackPublishedEventForIpCamera;
    private handleTrackSubscribedEventForIpCamera;
    private isIpCam;
}
export {};
