"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Connection = void 0;
const livekit_client_1 = require("livekit-client");
const Stream_1 = require("./Stream");
const TypeOfVideo_1 = require("../OpenViduInternal/Enums/TypeOfVideo");
const OpenViduLogger_1 = require("../OpenViduInternal/Logger/OpenViduLogger");
/**
 * @hidden
 */
const logger = OpenViduLogger_1.OpenViduLogger.getInstance();
/**
 * Livekit Participant
 */
class Connection {
    constructor(session, participant, remoteStream) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        let msg = "'Connection' created ";
        this.participant = participant;
        this.session = session;
        this.connectionId = this.participant.identity;
        this.creationTime = (_b = (_a = this.participant.joinedAt) === null || _a === void 0 ? void 0 : _a.getTime()) !== null && _b !== void 0 ? _b : -1;
        this.updatePropertiesFromMetadata(this.participant.metadata);
        if (this.participant instanceof livekit_client_1.RemoteParticipant) {
            msg += "(remote) with 'connectionId' [" + this.connectionId + ']';
            let videoStreamTrack;
            let audioStreamTrack;
            const videoDefined = remoteStream != null ? ((_c = remoteStream.video) === null || _c === void 0 ? void 0 : _c.id) != null : true;
            const audioDefined = remoteStream != null ? ((_d = remoteStream.audio) === null || _d === void 0 ? void 0 : _d.id) != null : true;
            this.participant.trackPublications.forEach((track) => {
                if (track.kind === livekit_client_1.Track.Kind.Video && videoDefined) {
                    videoStreamTrack = track;
                }
                else if (track.kind === livekit_client_1.Track.Kind.Audio && audioDefined) {
                    audioStreamTrack = track;
                }
            });
            if (videoStreamTrack || audioStreamTrack) {
                let videoDimensions;
                if (!!videoStreamTrack) {
                    let videoConstraints = videoStreamTrack.dimensions;
                    videoDimensions = videoConstraints
                        ? { width: videoConstraints.width, height: videoConstraints.height }
                        : { width: 0, height: 0 };
                }
                const createdAt = participant['participantInfo']
                    ? Number(BigInt(participant['participantInfo'].joinedAt)) * 1000
                    : new Date().getTime();
                const streamId = videoStreamTrack ? videoStreamTrack.trackName : audioStreamTrack.trackName;
                const streamOptions = {
                    id: streamId,
                    createdAt,
                    connection: this,
                    hasAudio: !!audioStreamTrack,
                    hasVideo: !!videoStreamTrack,
                    audioActive: !!audioStreamTrack && !((_e = audioStreamTrack.audioTrack) === null || _e === void 0 ? void 0 : _e.isMuted),
                    videoActive: !!videoStreamTrack && !((_f = videoStreamTrack.videoTrack) === null || _f === void 0 ? void 0 : _f.isMuted),
                    typeOfVideo: !!videoStreamTrack
                        ? videoStreamTrack.source === livekit_client_1.Track.Source.ScreenShare
                            ? TypeOfVideo_1.TypeOfVideo.SCREEN
                            : TypeOfVideo_1.TypeOfVideo.CAMERA
                        : undefined,
                    frameRate: !!videoStreamTrack
                        ? Number((_h = (_g = videoStreamTrack.videoTrack) === null || _g === void 0 ? void 0 : _g.mediaStreamTrack.getConstraints().frameRate) === null || _h === void 0 ? void 0 : _h.toString())
                        : undefined,
                    videoDimensions: videoDimensions,
                    filter: undefined
                };
                const stream = new Stream_1.Stream(this.session, streamOptions);
                stream.connection = this;
                this.stream = stream;
            }
        }
        logger.log(msg);
    }
    updatePropertiesFromMetadata(metadata) {
        if (!metadata) {
            this.data = '';
            return;
        }
        const parsedMetadata = JSON.parse(metadata);
        this.role = parsedMetadata.role;
        this.record = parsedMetadata.record;
        const clientData = parsedMetadata.clientData || '';
        const serverData = parsedMetadata.serverData || '';
        if (clientData && serverData) {
            this.data = `${clientData}%/%${serverData}`;
        }
        else {
            this.data = `${clientData || serverData}`;
        }
    }
}
exports.Connection = Connection;
//# sourceMappingURL=Connection.js.map