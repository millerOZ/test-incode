"use strict";
/*
 * (C) Copyright 2017-2022 OpenVidu (https://openvidu.io)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Filter = void 0;
const OpenViduError_1 = require("../OpenViduInternal/Enums/OpenViduError");
const OpenViduLogger_1 = require("../OpenViduInternal/Logger/OpenViduLogger");
/**
 * @hidden
 */
const logger = OpenViduLogger_1.OpenViduLogger.getInstance();
/**
 * **WARNING**: experimental option. This interface may change in the near future
 *
 * Video/audio filter applied to a Stream. See {@link Stream.applyFilter}
 */
class Filter {
    /**
     * @hidden
     */
    constructor(type, options) {
        /**
         * @hidden
         */
        this.handlers = new Map();
        this.type = type;
        this.options = options;
    }
    /**
     * Executes a filter method. Available methods are specific for each filter
     *
     * @param method Name of the method
     * @param params Parameters of the method
     */
    execMethod(method, params) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.info('Executing filter method to stream ' + this.stream.streamId);
            if (this.type.startsWith('VB:')) {
                if (typeof params === 'string') {
                    try {
                        params = JSON.parse(params);
                    }
                    catch (error) {
                        throw new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR, 'Wrong params syntax: ' + error);
                    }
                }
                if (method === 'update') {
                    if (!this.stream.videoTrack || !this.stream.videoTrack.getProcessor()) {
                        throw new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR, 'There is no Virtual Background filter applied');
                    }
                    else {
                        let updateParams;
                        if (this.type === 'VB:image') {
                            if (!params['url']) {
                                throw new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR, 'Parameter "url" is required for virtual background of type "image"');
                            }
                            else {
                                yield Filter.waitForImageToBeLoaded(params['url']);
                            }
                            updateParams = { imagePath: params['url'] };
                        }
                        else {
                            if (!params['blurRadius']) {
                                throw new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR, 'Parameter "blurRadius" is required for virtual background of type "blur"');
                            }
                            updateParams = { blurRadius: params['blurRadius'] };
                        }
                        const virtualBackground = this.stream.videoTrack.getProcessor();
                        try {
                            yield virtualBackground.updateTransformerOptions(updateParams);
                            logger.info('Filter method successfully executed on Stream ' + this.stream.streamId);
                            this.stream.filter.lastExecMethod = { method, params };
                            return;
                        }
                        catch (error) {
                            if (error.name === OpenViduError_1.OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR) {
                                throw new OpenViduError_1.OpenViduError(error.name, error.message);
                            }
                            else {
                                throw new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR, 'Error updating values on Virtual Background filter: ' + error);
                            }
                        }
                    }
                }
                else {
                    throw new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR, `Unknown Virtual Background method "${method}"`);
                }
            }
            else {
                throw new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.GENERIC_ERROR, 'Server side filters not supported');
            }
        });
    }
    /**
     * Subscribe to certain filter event. Available events are specific for each filter
     *
     * @param eventType Event to which subscribe to.
     * @param handler Function to execute upon event dispatched. It receives as parameter a {@link FilterEvent} object
     *
     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the event listener was successfully attached to the filter and rejected with an Error object if not
     */
    addEventListener(eventType, handler) {
        throw new Error("'addEventListener' method is not ready yet");
        // return new Promise((resolve, reject) => {
        //     logger.info('Adding filter event listener to event ' + eventType + ' to stream ' + this.stream.streamId);
        //     this.stream.session.openvidu.sendRequest(
        //         'addFilterEventListener',
        //         { streamId: this.stream.streamId, eventType },
        //         (error, response) => {
        //             if (error) {
        //                 logger.error(
        //                     'Error adding filter event listener to event ' + eventType + 'for Stream ' + this.stream.streamId,
        //                     error
        //                 );
        //                 if (error.code === 401) {
        //                     return reject(
        //                         new OpenViduError(
        //                             OpenViduErrorName.OPENVIDU_PERMISSION_DENIED,
        //                             "You don't have permissions to add a filter event listener"
        //                         )
        //                     );
        //                 } else {
        //                     return reject(error);
        //                 }
        //             } else {
        //                 this.handlers.set(eventType, handler);
        //                 logger.info(
        //                     'Filter event listener to event ' + eventType + ' successfully applied on Stream ' + this.stream.streamId
        //                 );
        //                 return resolve();
        //             }
        //         }
        //     );
        // });
    }
    /**
     * Removes certain filter event listener previously set.
     *
     * @param eventType Event to unsubscribe from.
     *
     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the event listener was successfully removed from the filter and rejected with an Error object in other case
     */
    removeEventListener(eventType) {
        throw new Error("'removeEventListener' method is not ready yet");
        // return new Promise((resolve, reject) => {
        //     logger.info('Removing filter event listener to event ' + eventType + ' to stream ' + this.stream.streamId);
        //     this.stream.session.openvidu.sendRequest(
        //         'removeFilterEventListener',
        //         { streamId: this.stream.streamId, eventType },
        //         (error, response) => {
        //             if (error) {
        //                 logger.error(
        //                     'Error removing filter event listener to event ' + eventType + 'for Stream ' + this.stream.streamId,
        //                     error
        //                 );
        //                 if (error.code === 401) {
        //                     return reject(
        //                         new OpenViduError(
        //                             OpenViduErrorName.OPENVIDU_PERMISSION_DENIED,
        //                             "You don't have permissions to add a filter event listener"
        //                         )
        //                     );
        //                 } else {
        //                     return reject(error);
        //                 }
        //             } else {
        //                 this.handlers.delete(eventType);
        //                 logger.info(
        //                     'Filter event listener to event ' + eventType + ' successfully removed on Stream ' + this.stream.streamId
        //                 );
        //                 return resolve();
        //             }
        //         }
        //     );
        // });
    }
    /**
     * @hidden
     */
    static waitForImageToBeLoaded(url) {
        const htmlImg = document.createElement('img');
        htmlImg.src = url;
        htmlImg.crossOrigin = 'anonymous';
        htmlImg['originalSrc'] = url;
        return new Promise((resolve, reject) => {
            htmlImg.onerror = () => {
                return reject({
                    name: 'VIRTUAL_BACKGROUND_ERROR',
                    message: 'Error loading background image located at ' + htmlImg.src
                });
            };
            if (htmlImg.complete) {
                return resolve(undefined);
            }
            else {
                htmlImg.onload = () => {
                    return resolve(undefined);
                };
            }
        });
    }
}
exports.Filter = Filter;
//# sourceMappingURL=Filter.js.map