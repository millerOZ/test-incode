"use strict";
// Participant tracks combined into a single Stream
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Stream = void 0;
const TypeOfVideo_1 = require("../OpenViduInternal/Enums/TypeOfVideo");
const Platform_1 = require("../OpenViduInternal/Utils/Platform");
const Filter_1 = require("./Filter");
const Publisher_1 = require("./Publisher");
const track_processors_1 = require("@livekit/track-processors");
const EventEmitter = require("wolfy87-eventemitter");
/**
 * @hidden
 */
const hark = require("hark");
const PublisherSpeakingEvent_1 = require("../OpenViduInternal/Events/PublisherSpeakingEvent");
const StreamManagerEvent_1 = require("../OpenViduInternal/Events/StreamManagerEvent");
const OpenViduError_1 = require("../OpenViduInternal/Enums/OpenViduError");
const OpenViduLogger_1 = require("../OpenViduInternal/Logger/OpenViduLogger");
/**
 * @hidden
 */
const platform = Platform_1.PlatformUtils.getInstance();
/**
 * @hidden
 */
const logger = OpenViduLogger_1.OpenViduLogger.getInstance();
/**
 * Represents each one of the media streams available in OpenVidu Server for certain session.
 * Each {@link Publisher} and {@link Subscriber} has an attribute of type Stream, as they give access
 * to one of them (sending and receiving it, respectively)
 */
class Stream {
    /**
     * @hidden
     */
    constructor(session, options) {
        /**
         * @hidden
         */
        this.internalEmitter = {};
        /**
         * @hidden
         */
        this.isLocalStreamReadyToPublish = false;
        /**
         * @hidden
         */
        this.isReadyToAttach = false;
        /**
         * @hidden
         */
        this.ee = new EventEmitter();
        /**
         * @hidden
         */
        this.harkSpeakingEnabled = false;
        /**
         * @hidden
         */
        this.harkSpeakingEnabledOnce = false;
        /**
         * @hidden
         */
        this.harkStoppedSpeakingEnabled = false;
        /**
         * @hidden
         */
        this.harkStoppedSpeakingEnabledOnce = false;
        /**
         * @hidden
         */
        this.harkVolumeChangeEnabled = false;
        /**
         * @hidden
         */
        this.harkVolumeChangeEnabledOnce = false;
        this.session = session;
        this.connection = session.connection;
        if ('id' in options) {
            // InboundStreamOptions: stream belongs to a Subscriber (remote)
            this.handleInboundStreamOptions(options);
        }
        else {
            // OutboundStreamOptions: stream belongs to a Publisher (local)
            this.handleOutboundStreamOptions(options);
        }
    }
    /**
     * Returns the internal MediaStream object associated to this stream (https://developer.mozilla.org/en-US/docs/Web/API/MediaStream)
     * @returns Native MediaStream Web API object
     */
    getMediaStream() {
        let mediaStream = new MediaStream();
        if (this.videoTrack && this.audioTrack) {
            // Both audio and video
            if (this.videoTrack.mediaStream != null && this.videoTrack.mediaStream === this.audioTrack.mediaStream) {
                // Both tracks share the same MediaStream object
                return this.videoTrack.mediaStream;
            }
            else {
                // Create a new MediaStream object with both tracks
                mediaStream.addTrack(this.videoTrack.mediaStreamTrack);
                mediaStream.addTrack(this.audioTrack.mediaStreamTrack);
                return mediaStream;
            }
        }
        else if (this.videoTrack) {
            // Only video
            if (this.videoTrack.mediaStream) {
                // Video track is already part of a MediaStream object
                return this.videoTrack.mediaStream;
            }
            else {
                // Create a new MediaStream object with the video track
                mediaStream.addTrack(this.videoTrack.mediaStreamTrack);
                return mediaStream;
            }
        }
        else if (this.audioTrack) {
            // Only audio
            if (this.audioTrack.mediaStream) {
                // Audio track is already part of a MediaStream object
                return this.audioTrack.mediaStream;
            }
            else {
                // Create a new MediaStream object with the audio track
                mediaStream.addTrack(this.audioTrack.mediaStreamTrack);
                return mediaStream;
            }
        }
        else {
            return mediaStream;
        }
    }
    /**
     * Returns the internal RTCPeerConnection object associated to this stream (https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection)
     *
     * @returns Native RTCPeerConnection Web API object
     */
    getRTCPeerConnection() {
        var _a;
        const pc = (_a = this.session.room.engine.pcManager) === null || _a === void 0 ? void 0 : _a.publisher['_pc'];
        if (!pc) {
            return { getSenders: () => [] };
        }
        return pc;
    }
    /**
     * @hidden
     */
    disposeWebRtcPeer() { }
    /**
     * @hidden
     */
    disposeMediaStream() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    /**
     * @hidden
     */
    publish() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                if (this.isLocalStreamReadyToPublish) {
                    // Initialize TrackPublishOptions
                    let streamName = `str__${this.session.room.localParticipant.identity}__${Math.random().toString(36).substr(2, 8)}`;
                    streamName += '__V__';
                    if (this.videoTrack) {
                        streamName += `${this.videoTrack.kind}-${this.videoTrack.source}`;
                        if (!this.videoActive)
                            streamName += '-muted';
                    }
                    streamName += '__A__';
                    if (this.audioTrack) {
                        streamName += `${this.audioTrack.kind}-${this.audioTrack.source}`;
                        if (!this.audioActive)
                            streamName += '-muted';
                    }
                    if (this.videoTrack) {
                        this.videoPublishOptions = {
                            name: streamName
                        };
                    }
                    if (this.audioTrack) {
                        this.audioPublishOptions = {
                            name: streamName
                        };
                    }
                    const localParticipant = this.session.localParticipant;
                    const promises = [];
                    try {
                        if (this.videoTrack) {
                            if (!this.videoActive) {
                                yield this.videoTrack.mute();
                            }
                            // Initialize video dimensions
                            try {
                                this.videoDimensions = yield this.getVideoDimensions();
                                if (this.isSendingScreen()) {
                                    // Set interval to listen for screen resize events
                                    this.screenShareResizeInterval = setInterval(() => __awaiter(this, void 0, void 0, function* () {
                                        const newDimensions = yield this.getVideoDimensions();
                                        const widthChanged = newDimensions != null && newDimensions.width !== this.videoDimensions.width;
                                        const heightChanged = newDimensions != null && newDimensions.height !== this.videoDimensions.height;
                                        if (this.isReadyToAttach && (widthChanged || heightChanged)) {
                                            this.session.openvidu.sendVideoDimensionsChangedEvent(this.streamManager, 'screenResized', this.videoDimensions.width, this.videoDimensions.height, newDimensions.width || 0, newDimensions.height || 0);
                                        }
                                    }), 650);
                                }
                            }
                            catch (error) {
                                logger.error('Error initializing video dimensions', error);
                            }
                            promises.push(localParticipant.publishTrack(this.videoTrack, this.videoPublishOptions));
                        }
                        else {
                            promises.push(Promise.resolve(undefined));
                        }
                        if (this.audioTrack) {
                            if (!this.audioActive) {
                                yield this.audioTrack.mute();
                            }
                            promises.push(localParticipant.publishTrack(this.audioTrack, this.audioPublishOptions));
                        }
                        else {
                            promises.push(Promise.resolve(undefined));
                        }
                        // [videoTrackPub, audioTrackPub] = await Promise.all(promises);
                        const results = yield Promise.allSettled(promises);
                        const [videoTrackPub, audioTrackPub] = results.map((result) => (result.status === 'fulfilled' ? result.value : null));
                        // It is now that the track sids are defined and streamId can be built
                        this.streamId = videoTrackPub ? videoTrackPub.trackName : audioTrackPub.trackName;
                        this.streamReadyToAttach();
                        resolve();
                    }
                    catch (error) {
                        logger.error('Error publishing tracks', error);
                        reject(error);
                    }
                }
                else {
                    this.ee.once('stream-ready-to-publish', () => __awaiter(this, void 0, void 0, function* () {
                        this.publish()
                            .then(() => resolve())
                            .catch((error) => reject(error));
                    }));
                }
            }));
        });
    }
    /**
     * @hidden
     */
    streamReadyToPublish() {
        this.isLocalStreamReadyToPublish = true;
        this.ee.emitEvent('stream-ready-to-publish', []);
    }
    /**
     * @hidden
     */
    streamReadyToAttach() {
        this.isReadyToAttach = true;
        this.initHarkEvents();
        this.ee.emit('openvidu-stream-ready-to-attach', []);
    }
    /**
     * @hidden
     */
    streamJustDestroyed() {
        this.isReadyToAttach = false;
        this.isLocalStreamReadyToPublish = false;
        if (!!this.speechEvent) {
            this.disableAllHarkEvents();
        }
        if (this.screenShareResizeInterval) {
            clearInterval(this.screenShareResizeInterval);
            delete this.screenShareResizeInterval;
        }
    }
    /**
     * @hidden
     */
    disableAllHarkEvents() {
        this.disableHarkSpeakingEvent(false);
        this.disableHarkStoppedSpeakingEvent(false);
        this.disableHarkVolumeChangeEvent(false);
    }
    /**
     * @hidden
     */
    isLocal() {
        return !this.inboundStreamOpts && !!this.outboundStreamOpts;
    }
    /**
     * @hidden
     */
    isSendingAudio() {
        return (!!this.outboundStreamOpts &&
            this.outboundStreamOpts.publisherProperties.audioSource !== null &&
            this.outboundStreamOpts.publisherProperties.audioSource !== false);
    }
    /**
     * @hidden
     */
    isSendingVideo() {
        return (!!this.outboundStreamOpts &&
            this.outboundStreamOpts.publisherProperties.videoSource !== null &&
            this.outboundStreamOpts.publisherProperties.videoSource !== false);
    }
    /**
     * @hidden
     */
    isSendingScreen() {
        let screen = false;
        if (typeof MediaStreamTrack !== 'undefined' &&
            this.outboundStreamOpts.publisherProperties.videoSource instanceof MediaStreamTrack) {
            let trackSettings = this.outboundStreamOpts.publisherProperties.videoSource.getSettings();
            if (trackSettings.displaySurface) {
                screen = ['monitor', 'window', 'browser'].includes(trackSettings.displaySurface);
            }
        }
        if (!screen) {
            if (platform.isElectron()) {
                screen =
                    typeof this.outboundStreamOpts.publisherProperties.videoSource === 'string' &&
                        this.outboundStreamOpts.publisherProperties.videoSource.startsWith('screen:');
            }
            else {
                screen = this.outboundStreamOpts.publisherProperties.videoSource === 'screen';
            }
        }
        return !!this.outboundStreamOpts && screen;
    }
    /**
     * @hidden
     */
    getVideoDimensions() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.videoTrack.waitForDimensions();
        });
    }
    /**
     * ! Not implemented yet
     * Recreates the media connection with the server. This entails the disposal of the previous RTCPeerConnection and the re-negotiation
     * of a new one, that will apply the same properties.
     *
     * This method can be useful in those situations were there the media connection breaks and OpenVidu is not able to recover on its own
     * for any kind of unanticipated reason (see [Automatic reconnection](/en/stable/advanced-features/automatic-reconnection/)).
     *
     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the reconnection operation was successful and rejected with an Error object if not
     */
    reconnect() {
        return Promise.resolve();
    }
    /**
     * Applies an audio/video filter to the stream.
     *
     * @param type Type of filter applied. See {@link Filter.type}
     * @param options Parameters used to initialize the filter. See {@link Filter.options}
     *
     * @returns A Promise (to which you can optionally subscribe to) that is resolved to the applied filter if success and rejected with an Error object if not
     */
    applyFilter(type, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (type !== 'VB:blur' && type !== 'VB:image') {
                throw new Error('Filter ' + type + ' not supported');
            }
            if (!this.videoTrack) {
                throw new Error('The Virtual Background filter requires a video track to be applied');
            }
            if (!this.isLocal()) {
                throw new Error('Filter can only be applied to local streams');
            }
            const localTrack = this.videoTrack;
            if (localTrack.getProcessor() != undefined) {
                throw new Error('There is already a filter applied to Stream ' + this.streamId);
            }
            try {
                switch (type) {
                    case 'VB:blur':
                        const blur = (0, track_processors_1.BackgroundBlur)(10);
                        if (this.streamManager && this.streamManager instanceof Publisher_1.Publisher) {
                            yield this.streamManager.runPromiseAndMuteLocalVideosIfNeeded(() => localTrack.setProcessor(blur));
                        }
                        else {
                            yield localTrack.setProcessor(blur);
                        }
                        break;
                    case 'VB:image':
                        if (!options['url']) {
                            throw new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR, 'Parameter "url" is required for virtual background of type "image"');
                        }
                        else {
                            yield Filter_1.Filter.waitForImageToBeLoaded(options['url']);
                        }
                        const image = (0, track_processors_1.VirtualBackground)(options['url']);
                        if (this.streamManager && this.streamManager instanceof Publisher_1.Publisher) {
                            yield this.streamManager.runPromiseAndMuteLocalVideosIfNeeded(() => localTrack.setProcessor(image));
                        }
                        else {
                            yield localTrack.setProcessor(image);
                        }
                        break;
                }
            }
            catch (error) {
                throw new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR, error.message);
            }
            this.filter = new Filter_1.Filter(type, options);
            this.filter.stream = this;
            return this.filter;
        });
    }
    /**
     * Removes an audio/video filter previously applied.
     *
     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the previously applied filter has been successfully removed and rejected with an Error object in other case
     */
    removeFilter() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.videoTrack) {
                throw new Error('No video track to remove filter');
            }
            if (!this.isLocal()) {
                throw new Error('Filter can only be removed from local streams');
            }
            const localTrack = this.videoTrack;
            if (localTrack.getProcessor() != undefined) {
                yield this.streamManager.runPromiseAndMuteLocalVideosIfNeeded(() => localTrack.stopProcessor());
                delete this.filter;
            }
            else {
                throw new Error('Stream ' + this.streamId + ' has no filter applied');
            }
        });
    }
    /**
     * ! Not supported in adapter. Test app uses it
     * @hidden
     */
    getSelectedIceCandidate() {
        throw new Error("'getSelectedIceCandidate' method is not ready yet.");
    }
    /**
     * ! Not supported in adapter. Test app uses it
     * @hidden
     */
    getLocalIceCandidateList() {
        throw new Error("'getLocalIceCandidateList' method is not ready yet.");
    }
    /**
     * ! Not supported in adapter. Test app uses it
     * @hidden
     */
    getRemoteIceCandidateList() {
        throw new Error("'getRemoteIceCandidateList' method is not ready yet.");
    }
    /**
     * ! Not supported in adapter. Test app uses it
     *
     * @hidden
     */
    getWebRtcPeer() {
        throw new Error("'getWebRtcPeer' method is not ready yet.");
    }
    handleInboundStreamOptions(options) {
        this.inboundStreamOpts = options;
        this.streamId = this.inboundStreamOpts.id;
        this.creationTime = this.inboundStreamOpts.createdAt;
        this.hasAudio = this.inboundStreamOpts.hasAudio;
        this.hasVideo = this.inboundStreamOpts.hasVideo;
        if (this.hasAudio) {
            this.audioActive = this.inboundStreamOpts.audioActive;
        }
        if (this.hasVideo) {
            this.videoActive = this.inboundStreamOpts.videoActive;
            this.typeOfVideo = this.inboundStreamOpts.typeOfVideo;
            this.frameRate = this.inboundStreamOpts.frameRate === -1 ? undefined : this.inboundStreamOpts.frameRate;
            this.videoDimensions = this.inboundStreamOpts.videoDimensions;
        }
        // TODO: Add filter
        // this.handleFilter(options.filter);
    }
    handleOutboundStreamOptions(options) {
        var _a, _b, _c, _d, _e, _f;
        this.outboundStreamOpts = options;
        this.hasAudio = this.isSendingAudio();
        this.hasVideo = this.isSendingVideo();
        if (this.hasAudio) {
            this.audioActive = !!((_a = this.outboundStreamOpts.publisherProperties) === null || _a === void 0 ? void 0 : _a.publishAudio);
        }
        if (this.hasVideo) {
            this.videoActive = !!((_b = this.outboundStreamOpts.publisherProperties) === null || _b === void 0 ? void 0 : _b.publishVideo);
            this.frameRate = (_c = this.outboundStreamOpts.publisherProperties) === null || _c === void 0 ? void 0 : _c.frameRate;
            const resolutionString = (_d = this.outboundStreamOpts.publisherProperties) === null || _d === void 0 ? void 0 : _d.resolution;
            if (resolutionString) {
                const [widthStr, heightStr] = resolutionString.split('x');
                const width = Number(widthStr);
                const height = Number(heightStr);
                if (!isNaN(width) && !isNaN(height)) {
                    this.videoDimensions = { width, height };
                }
            }
            if (typeof MediaStreamTrack !== 'undefined' &&
                ((_f = (_e = this.outboundStreamOpts) === null || _e === void 0 ? void 0 : _e.publisherProperties) === null || _f === void 0 ? void 0 : _f.videoSource) instanceof MediaStreamTrack) {
                this.typeOfVideo = TypeOfVideo_1.TypeOfVideo.CUSTOM;
            }
            else {
                this.typeOfVideo = this.isSendingScreen() ? TypeOfVideo_1.TypeOfVideo.SCREEN : TypeOfVideo_1.TypeOfVideo.CAMERA;
            }
        }
        // this.handleFilter(options.publisherProperties?.filter);
    }
    // TODO: Uncomment and implement the handleFilter method
    // private handleFilter(filter: any): void {
    //     if (!!filter && Object.keys(filter).length > 0) {
    //         if (!!filter.lastExecMethod && Object.keys(filter.lastExecMethod).length === 0) {
    //             delete filter.lastExecMethod;
    //         }
    //         this.filter = filter;
    //     }
    // }
    /**
     * @hidden
     */
    enableHarkSpeakingEvent() {
        this.setHarkListenerIfNotExists();
        if (!this.harkSpeakingEnabled && !!this.speechEvent) {
            this.harkSpeakingEnabled = true;
            this.speechEvent.on('speaking', () => {
                this.session.publicEmmiter.emitEvent('publisherStartSpeaking', [
                    new PublisherSpeakingEvent_1.PublisherSpeakingEvent(this.session, 'publisherStartSpeaking', this.connection, this.streamId)
                ]);
                this.streamManager.emitEvent('publisherStartSpeaking', [
                    new PublisherSpeakingEvent_1.PublisherSpeakingEvent(this.streamManager, 'publisherStartSpeaking', this.connection, this.streamId)
                ]);
                this.harkSpeakingEnabledOnce = false; // Disable 'once' version if 'on' version was triggered
            });
        }
    }
    /**
     * @hidden
     */
    enableOnceHarkSpeakingEvent() {
        this.setHarkListenerIfNotExists();
        if (!this.harkSpeakingEnabledOnce && !!this.speechEvent) {
            this.harkSpeakingEnabledOnce = true;
            this.speechEvent.once('speaking', () => {
                if (this.harkSpeakingEnabledOnce) {
                    // If the listener has been disabled in the meantime (for example by the 'on' version) do not trigger the event
                    this.session.publicEmmiter.emitEvent('publisherStartSpeaking', [
                        new PublisherSpeakingEvent_1.PublisherSpeakingEvent(this.session, 'publisherStartSpeaking', this.connection, this.streamId)
                    ]);
                    this.streamManager.emitEvent('publisherStartSpeaking', [
                        new PublisherSpeakingEvent_1.PublisherSpeakingEvent(this.streamManager, 'publisherStartSpeaking', this.connection, this.streamId)
                    ]);
                }
                this.disableHarkSpeakingEvent(true);
            });
        }
    }
    /**
     * @hidden
     */
    disableHarkSpeakingEvent(disabledByOnce) {
        if (!!this.speechEvent) {
            this.harkSpeakingEnabledOnce = false;
            if (disabledByOnce) {
                if (this.harkSpeakingEnabled) {
                    // The 'on' version of this same event is enabled too. Do not remove the hark listener
                    return;
                }
            }
            else {
                this.harkSpeakingEnabled = false;
            }
            // Shutting down the hark event
            if (this.harkVolumeChangeEnabled ||
                this.harkVolumeChangeEnabledOnce ||
                this.harkStoppedSpeakingEnabled ||
                this.harkStoppedSpeakingEnabledOnce) {
                // Some other hark event is enabled. Cannot stop the hark process, just remove the specific listener
                this.speechEvent.off('speaking');
            }
            else {
                // No other hark event is enabled. We can get entirely rid of it
                this.speechEvent.stop();
                delete this.speechEvent;
            }
        }
    }
    /**
     * @hidden
     */
    enableHarkStoppedSpeakingEvent() {
        this.setHarkListenerIfNotExists();
        if (!this.harkStoppedSpeakingEnabled && !!this.speechEvent) {
            this.harkStoppedSpeakingEnabled = true;
            this.speechEvent.on('stopped_speaking', () => {
                this.session.publicEmmiter.emitEvent('publisherStopSpeaking', [
                    new PublisherSpeakingEvent_1.PublisherSpeakingEvent(this.session, 'publisherStopSpeaking', this.connection, this.streamId)
                ]);
                this.streamManager.emitEvent('publisherStopSpeaking', [
                    new PublisherSpeakingEvent_1.PublisherSpeakingEvent(this.streamManager, 'publisherStopSpeaking', this.connection, this.streamId)
                ]);
                this.harkStoppedSpeakingEnabledOnce = false; // Disable 'once' version if 'on' version was triggered
            });
        }
    }
    /**
     * @hidden
     */
    enableOnceHarkStoppedSpeakingEvent() {
        this.setHarkListenerIfNotExists();
        if (!this.harkStoppedSpeakingEnabledOnce && !!this.speechEvent) {
            this.harkStoppedSpeakingEnabledOnce = true;
            this.speechEvent.once('stopped_speaking', () => {
                if (this.harkStoppedSpeakingEnabledOnce) {
                    // If the listener has been disabled in the meantime (for example by the 'on' version) do not trigger the event
                    this.session.publicEmmiter.emitEvent('publisherStopSpeaking', [
                        new PublisherSpeakingEvent_1.PublisherSpeakingEvent(this.session, 'publisherStopSpeaking', this.connection, this.streamId)
                    ]);
                    this.streamManager.emitEvent('publisherStopSpeaking', [
                        new PublisherSpeakingEvent_1.PublisherSpeakingEvent(this.streamManager, 'publisherStopSpeaking', this.connection, this.streamId)
                    ]);
                }
                this.disableHarkStoppedSpeakingEvent(true);
            });
        }
    }
    /**
     * @hidden
     */
    disableHarkStoppedSpeakingEvent(disabledByOnce) {
        if (!!this.speechEvent) {
            this.harkStoppedSpeakingEnabledOnce = false;
            if (disabledByOnce) {
                if (this.harkStoppedSpeakingEnabled) {
                    // We are cancelling the 'once' listener for this event, but the 'on' version
                    // of this same event is enabled too. Do not remove the hark listener
                    return;
                }
            }
            else {
                this.harkStoppedSpeakingEnabled = false;
            }
            // Shutting down the hark event
            if (this.harkVolumeChangeEnabled ||
                this.harkVolumeChangeEnabledOnce ||
                this.harkSpeakingEnabled ||
                this.harkSpeakingEnabledOnce) {
                // Some other hark event is enabled. Cannot stop the hark process, just remove the specific listener
                this.speechEvent.off('stopped_speaking');
            }
            else {
                // No other hark event is enabled. We can get entirely rid of it
                this.speechEvent.stop();
                delete this.speechEvent;
            }
        }
    }
    /**
     * @hidden
     */
    enableHarkVolumeChangeEvent(force) {
        if (this.setHarkListenerIfNotExists()) {
            if (!this.harkVolumeChangeEnabled || force) {
                this.harkVolumeChangeEnabled = true;
                this.speechEvent.on('volume_change', (harkEvent) => {
                    const oldValue = this.speechEvent.oldVolumeValue;
                    const value = { newValue: harkEvent, oldValue };
                    this.speechEvent.oldVolumeValue = harkEvent;
                    this.streamManager.emitEvent('streamAudioVolumeChange', [
                        new StreamManagerEvent_1.StreamManagerEvent(this.streamManager, 'streamAudioVolumeChange', value)
                    ]);
                });
            }
        }
        else {
            // This way whenever the MediaStream object is available, the event listener will be automatically added
            this.harkVolumeChangeEnabled = true;
        }
    }
    /**
     * @hidden
     */
    enableOnceHarkVolumeChangeEvent(force) {
        if (this.setHarkListenerIfNotExists()) {
            if (!this.harkVolumeChangeEnabledOnce || force) {
                this.harkVolumeChangeEnabledOnce = true;
                this.speechEvent.once('volume_change', (harkEvent) => {
                    const oldValue = this.speechEvent.oldVolumeValue;
                    const value = { newValue: harkEvent, oldValue };
                    this.speechEvent.oldVolumeValue = harkEvent;
                    this.disableHarkVolumeChangeEvent(true);
                    this.streamManager.emitEvent('streamAudioVolumeChange', [
                        new StreamManagerEvent_1.StreamManagerEvent(this.streamManager, 'streamAudioVolumeChange', value)
                    ]);
                });
            }
        }
        else {
            // This way whenever the MediaStream object is available, the event listener will be automatically added
            this.harkVolumeChangeEnabledOnce = true;
        }
    }
    /**
     * @hidden
     */
    disableHarkVolumeChangeEvent(disabledByOnce) {
        if (!!this.speechEvent) {
            this.harkVolumeChangeEnabledOnce = false;
            if (disabledByOnce) {
                if (this.harkVolumeChangeEnabled) {
                    // We are cancelling the 'once' listener for this event, but the 'on' version
                    // of this same event is enabled too. Do not remove the hark listener
                    return;
                }
            }
            else {
                this.harkVolumeChangeEnabled = false;
            }
            // Shutting down the hark event
            if (this.harkSpeakingEnabled ||
                this.harkSpeakingEnabledOnce ||
                this.harkStoppedSpeakingEnabled ||
                this.harkStoppedSpeakingEnabledOnce) {
                // Some other hark event is enabled. Cannot stop the hark process, just remove the specific listener
                this.speechEvent.off('volume_change');
            }
            else {
                // No other hark event is enabled. We can get entirely rid of it
                this.speechEvent.stop();
                delete this.speechEvent;
            }
        }
    }
    /**
     * @hidden
     */
    initHarkEvents() {
        var _a;
        if (!!((_a = this.audioTrack) === null || _a === void 0 ? void 0 : _a.mediaStreamTrack)) {
            // Hark events can only be set if audio track is available
            if (this.session.anySpeechEventListenerEnabled('publisherStartSpeaking', true) ||
                this.streamManager.anySpeechEventListenerEnabled('publisherStartSpeaking', true)) {
                this.enableOnceHarkSpeakingEvent();
            }
            if (this.session.anySpeechEventListenerEnabled('publisherStartSpeaking', false) ||
                this.streamManager.anySpeechEventListenerEnabled('publisherStartSpeaking', false)) {
                this.enableHarkSpeakingEvent();
            }
            if (this.session.anySpeechEventListenerEnabled('publisherStopSpeaking', true) ||
                this.streamManager.anySpeechEventListenerEnabled('publisherStopSpeaking', true)) {
                this.enableOnceHarkStoppedSpeakingEvent();
            }
            if (this.session.anySpeechEventListenerEnabled('publisherStopSpeaking', false) ||
                this.streamManager.anySpeechEventListenerEnabled('publisherStopSpeaking', false)) {
                this.enableHarkStoppedSpeakingEvent();
            }
            if (this.streamManager.anySpeechEventListenerEnabled('streamAudioVolumeChange', true)) {
                this.enableOnceHarkVolumeChangeEvent(true);
            }
            if (this.streamManager.anySpeechEventListenerEnabled('streamAudioVolumeChange', false)) {
                this.enableHarkVolumeChangeEvent(true);
            }
        }
    }
    setHarkListenerIfNotExists() {
        var _a;
        if (!!((_a = this.audioTrack) === null || _a === void 0 ? void 0 : _a.mediaStreamTrack)) {
            if (!this.speechEvent) {
                const harkOptions = !!this.harkOptions
                    ? this.harkOptions
                    : this.session.openvidu.advancedConfiguration.publisherSpeakingEventsOptions || {};
                harkOptions.interval = typeof harkOptions.interval === 'number' ? harkOptions.interval : 100;
                harkOptions.threshold = typeof harkOptions.threshold === 'number' ? harkOptions.threshold : -50;
                const mediaStream = new MediaStream();
                mediaStream.addTrack(this.audioTrack.mediaStreamTrack);
                this.speechEvent = hark(mediaStream, harkOptions);
            }
            return true;
        }
        return false;
    }
}
exports.Stream = Stream;
//# sourceMappingURL=Stream.js.map